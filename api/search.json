[{"id":"c129c513711abfc697aa038953107f79","title":"Codeforces Hello 2024 题解(CF1919)","content":"代码见文末\nA Wallet Exchangehttps://codeforces.com/contest/1919/problem/A\n求和看奇偶\nB Plus-Minus Splithttps://codeforces.com/contest/1919/problem/B\n正负号个数作差取绝对值\nC Grouping Increaseshttps://codeforces.com/contest/1919/problem/C\n让递减的幅度尽量慢一点\nD 01 Treehttps://codeforces.com/contest/1919/problem/D\n对于一个数寻找它左右第一个比它小的数是否比它小 $1$，若均非则不存在树。特判如果没有 $0$ 亦不存在树\nF1 Wine Factory (Easy Version)$a_i-b_i$ 的前缀和和最小值减去 $b$ 数组的和即为答案，前者使用线段树维护\nCodeA/*******************************\n| Author:  KAZE_mae\n| Website: https://cloudfall.top\n| Problem: A. Wallet Exchange\n| Contest: Codeforces - Hello 2024\n| URL:     https://codeforces.com/contest/1919/problem/A\n| When:    2024-01-06 22:36:44\n| \n| Memory:  256 MB\n| Time:    1000 ms\n*******************************/\n\n/********************************************\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⠛⠛⠛⠿⣿⣿⣿⣿⣿⣷⠀⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠉⠀⠀⣠⣤⣤⣤⣤⣤⣤⣤⣀⠀⠉⠛⠿⠈⣦⠙⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⠟⠀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⠀⣼⣿⣦⠙⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⠿⠛⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣿⣿⣿⠀⠻⣿⣿⣿⣿⣿\n|⣿⡟⠀⠀⠤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⠆⠀⠀⠙⣿⣿⣿\n|⣿⣆⠀⠀⠀⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠿⢿⠿⠀⠀⠀⠀ ⣿⣿⣿\n|⣿⣿⣦⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⣤⣆⠀⢠⣿⣿⣿⣿\n|⣿⣿⠋⠀⣿⣿⣿⣿⠋⠀⠈⢿⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣿⠉⠀⠈⣿⣿⣿⣿⡆⠈⣿⣿⣿⣿\n|⣿⣿⠀⠸⠿⠿⣿⣿⠀⠀⠀⣸⣿⣿⡁⠀⠀⠀⠀⢙⣿⣿⣧⠀⠀⠀ ⢠⣿⡿⠿⠿ ⢹⣿⣿⣿\n|⣟⠀⠀⠀⣀⠀⠀⠀⢙⣶⣾⣿⣿⣿⣿⣶⡄⢀⣴⣿⣿⣿⣿⣷⣶⡶⠁⠀⢀⠀⣀⠀⠀ ⢙⣿⣿\n|⣿⠀⠻⠿⠛⠛⠛⠷⢾⣿⣿⣿⣿⣿⣿⣿⠇⠙⣿⣿⣿⣿⣿⣿⣿⣿⠒⠛⠛⠻⠿⢿⠀⢿⣿⣿\n|⠟⠀⢀⢀⣤⣶⣶⣦⣾⣿⣿⣿⣿⣿⣿⢀⣶⣶⣀⠙⣿⣿⣿⣿⣿⣿⣦⣤⣶⣦⣄⠀⠀⠘⣿⣿\n|⣷⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣶⣿⣿\n|⣿⣆⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⢠⣿⣿⣿\n|⣿⣿⣄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⢀⣿⣿⣿⣿\n|⣿⣿⣿⣷⡀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⣴⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣶⣀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⢀⣴⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣤⣀⠀⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n*********************************************/\n\n// #include &lt;bits/stdc++.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;deque&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\nusing Ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate &lt;typename T&gt;\nusing pair2 = pair&lt;T, T&gt;;\nusing PII = pair&lt;int, int&gt;;\nusing PLI = pair&lt;ll, int&gt;;\nusing PLL = pair&lt;ll, ll&gt;;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B)&#123; return (ull)rng() % B; &#125;\n\n#define endl &#x27;\\n&#x27;\n#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; endl\n#define abs(a) ((a) &gt;= 0 ? (a) : -(a))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define mem(a, b) memset(a, b, sizeof(a))\n// #define max(a, b) ((a) &gt; (b) ? (a) : (b))\n// #define min(a, b) ((a) &lt; (b) ? (a) : (b))\n#define rep(i, a, n) for (int i = a; i &lt;= n; ++i)\n#define per(i, n, a) for (int i = n; i &gt;= a; --i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&amp;(-x))\n\nconst int N = 1000005; // 1e6 + 5\nconst int INF = 0x3f3f3f3f;\nconst long long LNF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\nconst int MOD = 998244353;\n\n// #define int long long\n\nlong long qmi(long long m, long long k, long long p = 9e18) &#123;\n    int res = 1 % p, t = m;\n    while (k) &#123;\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p, k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline long long gcd(long long a, long long b) &#123;return b ? gcd(b, a % b) : a;&#125;\nlong long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;  \n    if (!b) &#123; x = 1; y = 0; return a; &#125;  \n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;  \n    return d;\n&#125;\n\nlong long Sqrt(long long N) &#123;\n    __int128 sqrtN = sqrtl(N) - 1;\n    while (sqrtN + 1 &lt;= N / (sqrtN + 1))sqrtN++;\n    return sqrtN;\n&#125;\n// #define int long long\n\n\nvoid solve();\nsigned main() &#123;\n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    // cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);\n    int _ = 1; cin&gt;&gt; _; while(_ --)\n        solve();\n  return 0;\n&#125;\n#define int long long\n\nvoid solve() &#123;\n    int a, b;\n    cin&gt;&gt; a &gt;&gt; b;\n    cout&lt;&lt; ((a + b) &amp; 1 ? &quot;Alice&quot; : &quot;Bob&quot;) &lt;&lt;endl;\n&#125; \n\n\nB/*******************************\n| Author:  KAZE_mae\n| Website: https://cloudfall.top\n| Problem: B. Plus-Minus Split\n| Contest: Codeforces - Hello 2024\n| URL:     https://codeforces.com/contest/1919/problem/B\n| When:    2024-01-06 22:40:22\n| \n| Memory:  256 MB\n| Time:    1000 ms\n*******************************/\n\n/********************************************\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⠛⠛⠛⠿⣿⣿⣿⣿⣿⣷⠀⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠉⠀⠀⣠⣤⣤⣤⣤⣤⣤⣤⣀⠀⠉⠛⠿⠈⣦⠙⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⠟⠀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⠀⣼⣿⣦⠙⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⠿⠛⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣿⣿⣿⠀⠻⣿⣿⣿⣿⣿\n|⣿⡟⠀⠀⠤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⠆⠀⠀⠙⣿⣿⣿\n|⣿⣆⠀⠀⠀⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠿⢿⠿⠀⠀⠀⠀ ⣿⣿⣿\n|⣿⣿⣦⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⣤⣆⠀⢠⣿⣿⣿⣿\n|⣿⣿⠋⠀⣿⣿⣿⣿⠋⠀⠈⢿⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣿⠉⠀⠈⣿⣿⣿⣿⡆⠈⣿⣿⣿⣿\n|⣿⣿⠀⠸⠿⠿⣿⣿⠀⠀⠀⣸⣿⣿⡁⠀⠀⠀⠀⢙⣿⣿⣧⠀⠀⠀ ⢠⣿⡿⠿⠿ ⢹⣿⣿⣿\n|⣟⠀⠀⠀⣀⠀⠀⠀⢙⣶⣾⣿⣿⣿⣿⣶⡄⢀⣴⣿⣿⣿⣿⣷⣶⡶⠁⠀⢀⠀⣀⠀⠀ ⢙⣿⣿\n|⣿⠀⠻⠿⠛⠛⠛⠷⢾⣿⣿⣿⣿⣿⣿⣿⠇⠙⣿⣿⣿⣿⣿⣿⣿⣿⠒⠛⠛⠻⠿⢿⠀⢿⣿⣿\n|⠟⠀⢀⢀⣤⣶⣶⣦⣾⣿⣿⣿⣿⣿⣿⢀⣶⣶⣀⠙⣿⣿⣿⣿⣿⣿⣦⣤⣶⣦⣄⠀⠀⠘⣿⣿\n|⣷⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣶⣿⣿\n|⣿⣆⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⢠⣿⣿⣿\n|⣿⣿⣄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⢀⣿⣿⣿⣿\n|⣿⣿⣿⣷⡀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⣴⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣶⣀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⢀⣴⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣤⣀⠀⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n*********************************************/\n\n// #include &lt;bits/stdc++.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;deque&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\nusing Ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate &lt;typename T&gt;\nusing pair2 = pair&lt;T, T&gt;;\nusing PII = pair&lt;int, int&gt;;\nusing PLI = pair&lt;ll, int&gt;;\nusing PLL = pair&lt;ll, ll&gt;;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B)&#123; return (ull)rng() % B; &#125;\n\n#define endl &#x27;\\n&#x27;\n#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; endl\n#define abs(a) ((a) &gt;= 0 ? (a) : -(a))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define mem(a, b) memset(a, b, sizeof(a))\n// #define max(a, b) ((a) &gt; (b) ? (a) : (b))\n// #define min(a, b) ((a) &lt; (b) ? (a) : (b))\n#define rep(i, a, n) for (int i = a; i &lt;= n; ++i)\n#define per(i, n, a) for (int i = n; i &gt;= a; --i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&amp;(-x))\n\nconst int N = 1000005; // 1e6 + 5\nconst int INF = 0x3f3f3f3f;\nconst long long LNF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\nconst int MOD = 998244353;\n\n// #define int long long\n\nlong long qmi(long long m, long long k, long long p = 9e18) &#123;\n    int res = 1 % p, t = m;\n    while (k) &#123;\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p, k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline long long gcd(long long a, long long b) &#123;return b ? gcd(b, a % b) : a;&#125;\nlong long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;  \n    if (!b) &#123; x = 1; y = 0; return a; &#125;  \n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;  \n    return d;\n&#125;\n\nlong long Sqrt(long long N) &#123;\n    __int128 sqrtN = sqrtl(N) - 1;\n    while (sqrtN + 1 &lt;= N / (sqrtN + 1))sqrtN++;\n    return sqrtN;\n&#125;\n// #define int long long\n\n\nvoid solve();\nsigned main() &#123;\n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    // cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);\n    int _ = 1; cin&gt;&gt; _; while(_ --)\n        solve();\n  return 0;\n&#125;\n// #define int long long\n\nvoid solve() &#123;\n    int n, z = 0, f = 0;\n    string s;\n    cin&gt;&gt; n &gt;&gt; s;\n    for(int i = 0; i &lt; n; ++ i) &#123;\n        if(s[i] == &#x27;+&#x27;) ++ z;\n        else ++ f;\n    &#125;\n    // cout &lt;&lt; z &lt;&lt; &quot; &quot; &lt;&lt; f &lt;&lt;endl;\n    cout &lt;&lt; abs(z - f) &lt;&lt;endl;\n&#125; \n\n\nC/*******************************\n| Author:  KAZE_mae\n| Website: https://cloudfall.top\n| Problem: C. Grouping Increases\n| Contest: Codeforces - Hello 2024\n| URL:     https://codeforces.com/contest/1919/problem/C\n| When:    2024-01-06 22:43:32\n| \n| Memory:  256 MB\n| Time:    1000 ms\n*******************************/\n\n/********************************************\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⠛⠛⠛⠿⣿⣿⣿⣿⣿⣷⠀⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠉⠀⠀⣠⣤⣤⣤⣤⣤⣤⣤⣀⠀⠉⠛⠿⠈⣦⠙⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⠟⠀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⠀⣼⣿⣦⠙⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⠿⠛⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣿⣿⣿⠀⠻⣿⣿⣿⣿⣿\n|⣿⡟⠀⠀⠤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⠆⠀⠀⠙⣿⣿⣿\n|⣿⣆⠀⠀⠀⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠿⢿⠿⠀⠀⠀⠀ ⣿⣿⣿\n|⣿⣿⣦⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⣤⣆⠀⢠⣿⣿⣿⣿\n|⣿⣿⠋⠀⣿⣿⣿⣿⠋⠀⠈⢿⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣿⠉⠀⠈⣿⣿⣿⣿⡆⠈⣿⣿⣿⣿\n|⣿⣿⠀⠸⠿⠿⣿⣿⠀⠀⠀⣸⣿⣿⡁⠀⠀⠀⠀⢙⣿⣿⣧⠀⠀⠀ ⢠⣿⡿⠿⠿ ⢹⣿⣿⣿\n|⣟⠀⠀⠀⣀⠀⠀⠀⢙⣶⣾⣿⣿⣿⣿⣶⡄⢀⣴⣿⣿⣿⣿⣷⣶⡶⠁⠀⢀⠀⣀⠀⠀ ⢙⣿⣿\n|⣿⠀⠻⠿⠛⠛⠛⠷⢾⣿⣿⣿⣿⣿⣿⣿⠇⠙⣿⣿⣿⣿⣿⣿⣿⣿⠒⠛⠛⠻⠿⢿⠀⢿⣿⣿\n|⠟⠀⢀⢀⣤⣶⣶⣦⣾⣿⣿⣿⣿⣿⣿⢀⣶⣶⣀⠙⣿⣿⣿⣿⣿⣿⣦⣤⣶⣦⣄⠀⠀⠘⣿⣿\n|⣷⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣶⣿⣿\n|⣿⣆⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⢠⣿⣿⣿\n|⣿⣿⣄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⢀⣿⣿⣿⣿\n|⣿⣿⣿⣷⡀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⣴⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣶⣀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⢀⣴⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣤⣀⠀⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n*********************************************/\n\n// #include &lt;bits/stdc++.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;deque&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\nusing Ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate &lt;typename T&gt;\nusing pair2 = pair&lt;T, T&gt;;\nusing PII = pair&lt;int, int&gt;;\nusing PLI = pair&lt;ll, int&gt;;\nusing PLL = pair&lt;ll, ll&gt;;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B)&#123; return (ull)rng() % B; &#125;\n\n#define endl &#x27;\\n&#x27;\n#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; endl\n#define abs(a) ((a) &gt;= 0 ? (a) : -(a))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define mem(a, b) memset(a, b, sizeof(a))\n// #define max(a, b) ((a) &gt; (b) ? (a) : (b))\n// #define min(a, b) ((a) &lt; (b) ? (a) : (b))\n#define rep(i, a, n) for (int i = a; i &lt;= n; ++i)\n#define per(i, n, a) for (int i = n; i &gt;= a; --i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&amp;(-x))\n\nconst int N = 1000005; // 1e6 + 5\nconst int INF = 0x3f3f3f3f;\nconst long long LNF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\nconst int MOD = 998244353;\n\n// #define int long long\n\nlong long qmi(long long m, long long k, long long p = 9e18) &#123;\n    int res = 1 % p, t = m;\n    while (k) &#123;\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p, k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline long long gcd(long long a, long long b) &#123;return b ? gcd(b, a % b) : a;&#125;\nlong long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;  \n    if (!b) &#123; x = 1; y = 0; return a; &#125;  \n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;  \n    return d;\n&#125;\n\nlong long Sqrt(long long N) &#123;\n    __int128 sqrtN = sqrtl(N) - 1;\n    while (sqrtN + 1 &lt;= N / (sqrtN + 1))sqrtN++;\n    return sqrtN;\n&#125;\n// #define int long long\n\n\nvoid solve();\nsigned main() &#123;\n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    // cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);\n    int _ = 1; cin&gt;&gt; _; while(_ --)\n        solve();\n  return 0;\n&#125;\n// #define int long long\n\nvoid solve() &#123;\n    int n, ans = 0;\n    cin&gt;&gt; n;\n    vector&lt;int&gt; a(n), s, t;\n    for(int i = 0; i &lt; n; ++ i) &#123;\n        cin&gt;&gt; a[i];\n        if(s.empty()) s.push_back(a[i]);\n        else if(t.empty() &amp;&amp; a[i] &lt;= s.back()) s.push_back(a[i]);\n        else if(t.empty()) t.push_back(a[i]);\n        else &#123;\n            if(a[i] &lt;= s.back() &amp;&amp; a[i] &lt;= t.back()) &#123;\n                if(s.back() - a[i] &lt; t.back() - a[i]) s.push_back(a[i]);\n                else t.push_back(a[i]);\n            &#125;else if(a[i] &lt;= s.back()) s.push_back(a[i]);\n            else if(a[i] &lt;= t.back()) t.push_back(a[i]);\n            else if(a[i] - s.back() &gt; a[i] - t.back()) s.push_back(a[i]);\n            else t.push_back(a[i]);\n        &#125;\n    &#125;\n    // for(auto i : s) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt;endl;\n    // for(auto i : t) cout &lt;&lt; i &lt;&lt; &quot; &quot;; cout &lt;&lt;endl;\n    int q = 0;\n    for(int i = 0; i &lt; n - 1; ++ i) &#123;\n        if(a[i] &lt; a[i + 1]) q ++;\n    &#125;\n    if(!s.empty()) &#123;\n        for(int i = 0; i &lt; (int)s.size() - 1; ++ i) &#123;\n            if(s[i] &lt; s[i + 1]) ans ++;\n        &#125;\n    &#125;\n    if(!t.empty()) &#123;\n        for(int i = 0; i &lt; (int)t.size() - 1; ++ i) &#123;\n            if(t[i] &lt; t[i + 1]) ans ++;\n        &#125;\n    &#125;\n    // cout &lt;&lt; (!t.empty()) &lt;&lt; &quot; &quot; &lt;&lt; (!s.empty()) &lt;&lt;endl;\n    cout &lt;&lt; min(ans,INF) &lt;&lt;endl;\n&#125; \n\n\nD/*******************************\n| Author:  KAZE_mae\n| Website: https://cloudfall.top\n| Problem: D. 01 Tree\n| Contest: Codeforces - Hello 2024\n| URL:     https://codeforces.com/contest/1919/problem/D\n| When:    2024-01-07 00:02:11\n| \n| Memory:  256 MB\n| Time:    1000 ms\n*******************************/\n\n/********************************************\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⠛⠛⠛⠿⣿⣿⣿⣿⣿⣷⠀⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠉⠀⠀⣠⣤⣤⣤⣤⣤⣤⣤⣀⠀⠉⠛⠿⠈⣦⠙⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⠟⠀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⠀⣼⣿⣦⠙⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⠿⠛⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣿⣿⣿⠀⠻⣿⣿⣿⣿⣿\n|⣿⡟⠀⠀⠤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⠆⠀⠀⠙⣿⣿⣿\n|⣿⣆⠀⠀⠀⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠿⢿⠿⠀⠀⠀⠀ ⣿⣿⣿\n|⣿⣿⣦⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⣤⣆⠀⢠⣿⣿⣿⣿\n|⣿⣿⠋⠀⣿⣿⣿⣿⠋⠀⠈⢿⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣿⠉⠀⠈⣿⣿⣿⣿⡆⠈⣿⣿⣿⣿\n|⣿⣿⠀⠸⠿⠿⣿⣿⠀⠀⠀⣸⣿⣿⡁⠀⠀⠀⠀⢙⣿⣿⣧⠀⠀⠀ ⢠⣿⡿⠿⠿ ⢹⣿⣿⣿\n|⣟⠀⠀⠀⣀⠀⠀⠀⢙⣶⣾⣿⣿⣿⣿⣶⡄⢀⣴⣿⣿⣿⣿⣷⣶⡶⠁⠀⢀⠀⣀⠀⠀ ⢙⣿⣿\n|⣿⠀⠻⠿⠛⠛⠛⠷⢾⣿⣿⣿⣿⣿⣿⣿⠇⠙⣿⣿⣿⣿⣿⣿⣿⣿⠒⠛⠛⠻⠿⢿⠀⢿⣿⣿\n|⠟⠀⢀⢀⣤⣶⣶⣦⣾⣿⣿⣿⣿⣿⣿⢀⣶⣶⣀⠙⣿⣿⣿⣿⣿⣿⣦⣤⣶⣦⣄⠀⠀⠘⣿⣿\n|⣷⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣶⣿⣿\n|⣿⣆⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⢠⣿⣿⣿\n|⣿⣿⣄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⢀⣿⣿⣿⣿\n|⣿⣿⣿⣷⡀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⣴⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣶⣀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⢀⣴⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣤⣀⠀⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n*********************************************/\n\n// #include &lt;bits/stdc++.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;deque&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\nusing Ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate &lt;typename T&gt;\nusing pair2 = pair&lt;T, T&gt;;\nusing PII = pair&lt;int, int&gt;;\nusing PLI = pair&lt;ll, int&gt;;\nusing PLL = pair&lt;ll, ll&gt;;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B)&#123; return (ull)rng() % B; &#125;\n\n#define endl &#x27;\\n&#x27;\n#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; endl\n#define abs(a) ((a) &gt;= 0 ? (a) : -(a))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define mem(a, b) memset(a, b, sizeof(a))\n// #define max(a, b) ((a) &gt; (b) ? (a) : (b))\n// #define min(a, b) ((a) &lt; (b) ? (a) : (b))\n#define rep(i, a, n) for (int i = a; i &lt;= n; ++i)\n#define per(i, n, a) for (int i = n; i &gt;= a; --i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&amp;(-x))\n\nconst int N = 1000005; // 1e6 + 5\nconst int INF = 0x3f3f3f3f;\nconst long long LNF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\nconst int MOD = 998244353;\n\n// #define int long long\n\nlong long qmi(long long m, long long k, long long p = 9e18) &#123;\n    int res = 1 % p, t = m;\n    while (k) &#123;\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p, k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline long long gcd(long long a, long long b) &#123;return b ? gcd(b, a % b) : a;&#125;\nlong long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;  \n    if (!b) &#123; x = 1; y = 0; return a; &#125;  \n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;  \n    return d;\n&#125;\n\nlong long Sqrt(long long N) &#123;\n    __int128 sqrtN = sqrtl(N) - 1;\n    while (sqrtN + 1 &lt;= N / (sqrtN + 1))sqrtN++;\n    return sqrtN;\n&#125;\n\n// #define int long long\nstruct SEGT &#123;\n    #define ls id &lt;&lt; 1\n    #define rs id &lt;&lt; 1 | 1\n    struct Zhenen &#123;\n        long long val;\n    &#125;;\n    vector&lt;int&gt; a;\n    vector&lt;Zhenen&gt; seg;\n    SEGT(int n) : a(n + 1), seg(n * 4) &#123;&#125;\n\n    void update(int id) &#123;\n        seg[id].val = min(seg[ls].val, seg[rs].val);\n    &#125;\n\n\n    void pushdown(int id) &#123;\n        \n    &#125;\n\n    void build(int id, int l, int r) &#123;\n        if(l == r) seg[id].val = a[l];\n        else &#123;\n            int mid = l + r &gt;&gt; 1;\n            build(ls, l, mid);\n            build(rs, mid + 1, r);\n            update(id);\n        &#125;\n    &#125;\n    // 修改 [ql, qr] 为 t\n    void modify(int id, int l, int r, int ql, int qr, long long t) &#123;\n        if(l == ql &amp;&amp; r == qr) &#123;\n            seg[id].val = t;\n            return;\n        &#125;\n        // pushdown(id);\n        int mid = l + r &gt;&gt; 1;\n        if(qr &lt;= mid) modify(ls, l , mid, ql, qr, t);\n        else if(ql &gt; mid) modify(rs, mid + 1, r, ql, qr, t);\n        else &#123;\n            modify(ls, l, mid, ql, mid, t);\n            modify(rs, mid + 1, r, mid + 1, qr, t);\n        &#125;\n        update(id);\n    &#125;\n    \n    long long query(int id, int l, int r, int ql, int qr) &#123;\n        if(l == ql &amp;&amp; r == qr) return seg[id].val;\n        pushdown(id);\n        int mid = l + r &gt;&gt; 1;\n        if(qr &lt;= mid) return query(ls, l, mid, ql, qr);\n        else if(ql &gt; mid) return query(rs, mid + 1, r, ql, qr);\n        else return (query(ls, l, mid, ql, mid) + query(rs, mid + 1, r, mid + 1, qr));\n    &#125;\n    // 寻找 [ql, qr] 大于等于 d 的第一个数的下标, 不存在返回 -1\n    int search(int id, int l, int r, int ql, int qr, int d) &#123;\n        if(l == ql &amp;&amp; r == qr) &#123;\n            if(seg[id].val &gt;= d) return -1;\n            else &#123;\n                if(l == r) return l;\n                int mid = l + r &gt;&gt; 1;\n                if(seg[ls].val &lt; d) return search(ls, l, mid, ql, mid, d);\n                else return search(rs, mid + 1, r, mid + 1, qr, d);\n            &#125;\n        &#125;\n        // pushdown(id);\n        int mid = l + r &gt;&gt; 1;\n        if(qr &lt;= mid) return search(ls, l, mid, ql, qr, d);\n        else if(ql &gt; mid) return search(rs, mid + 1, r, ql, qr, d);\n        else &#123;\n            int pos = search(ls, l, mid, ql, mid, d);\n            if(pos == -1) return search(rs, mid + 1, r, mid + 1, qr, d);\n            else return pos;\n        &#125;\n    &#125;\n    #undef ls\n    #undef rs\n&#125;;\n\nstring solve();\nsigned main() &#123;\n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    // cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);\n    int _ = 1; cin&gt;&gt; _; while(_ --)\n        cout &lt;&lt; solve() &lt;&lt;endl;\n  return 0;\n&#125;\n// #define int long long\n\nstring solve() &#123;\n    int n, mn = INF;\n    cin&gt;&gt; n;\n    SEGT tr(n), rt(n);\n    priority_queue&lt;pair&lt;int, int&gt; &gt; q; \n    for(int i = 0; i &lt; n; ++ i) \n        cin&gt;&gt; tr.a[i + 1], q.push(&#123;tr.a[i + 1], i + 1&#125;), rt.a[n - i] = tr.a[i + 1], mn = min(mn, tr.a[i + 1]);\n    if(mn != 0) return &quot;NO&quot;;\n    tr.build(1, 1, n);\n    rt.build(1, 1, n);\n    while(!q.empty()) &#123;\n        auto [x, i] = q.top();\n        q.pop();\n        auto l = rt.search(1, 1, n, n - i + 1, n, rt.a[n - i + 1]), r = tr.search(1, 1, n, i, n, tr.a[i]);\n        if(l == -1 &amp;&amp; r == -1 &amp;&amp; !q.empty()) return &quot;NO&quot;;\n        else if(l != -1 &amp;&amp; r != -1 &amp;&amp; tr.a[i] - rt.a[l] &gt; 1 &amp;&amp; tr.a[i] - tr.a[r] &gt; 1) return &quot;NO&quot;;\n        else if(l != -1 &amp;&amp; r == -1 &amp;&amp; tr.a[i] - rt.a[l] &gt; 1) return &quot;NO&quot;;\n        else if(r != -1 &amp;&amp; l == -1 &amp;&amp; tr.a[i] - tr.a[r] &gt; 1) return &quot;NO&quot;;\n    &#125;\n    return &quot;YES&quot;;\n&#125;\n\nF1/*******************************\n| Author:  KAZE_mae\n| Website: https://cloudfall.top\n| Problem: F1. Wine Factory (Easy Version)\n| Contest: Codeforces - Hello 2024\n| URL:     https://codeforces.com/contest/1919/problem/F1\n| When:    2024-01-18 11:36:01\n| \n| Memory:  512 MB\n| Time:    5000 ms\n*******************************/\n\n/********************************************\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠛⠛⠛⠛⠛⠿⣿⣿⣿⣿⣿⣷⠀⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⠛⠉⠀⠀⣠⣤⣤⣤⣤⣤⣤⣤⣀⠀⠉⠛⠿⠈⣦⠙⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⠟⠀⢀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣤⠀⣼⣿⣦⠙⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⠿⠛⠀⢀⣴⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⣿⣿⣿⠀⠻⣿⣿⣿⣿⣿\n|⣿⡟⠀⠀⠤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⣿⣿⣿⠆⠀⠀⠙⣿⣿⣿\n|⣿⣆⠀⠀⠀⣻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⠀⠿⢿⠿⠀⠀⠀⠀ ⣿⣿⣿\n|⣿⣿⣦⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣷⣤⣀⣤⣆⠀⢠⣿⣿⣿⣿\n|⣿⣿⠋⠀⣿⣿⣿⣿⠋⠀⠈⢿⣿⣿⣿⠿⠿⠿⢿⣿⣿⣿⣿⠉⠀⠈⣿⣿⣿⣿⡆⠈⣿⣿⣿⣿\n|⣿⣿⠀⠸⠿⠿⣿⣿⠀⠀⠀⣸⣿⣿⡁⠀⠀⠀⠀⢙⣿⣿⣧⠀⠀⠀ ⢠⣿⡿⠿⠿ ⢹⣿⣿⣿\n|⣟⠀⠀⠀⣀⠀⠀⠀⢙⣶⣾⣿⣿⣿⣿⣶⡄⢀⣴⣿⣿⣿⣿⣷⣶⡶⠁⠀⢀⠀⣀⠀⠀ ⢙⣿⣿\n|⣿⠀⠻⠿⠛⠛⠛⠷⢾⣿⣿⣿⣿⣿⣿⣿⠇⠙⣿⣿⣿⣿⣿⣿⣿⣿⠒⠛⠛⠻⠿⢿⠀⢿⣿⣿\n|⠟⠀⢀⢀⣤⣶⣶⣦⣾⣿⣿⣿⣿⣿⣿⢀⣶⣶⣀⠙⣿⣿⣿⣿⣿⣿⣦⣤⣶⣦⣄⠀⠀⠘⣿⣿\n|⣷⠀⠹⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⣶⣿⣿\n|⣿⣆⠀⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠁⢠⣿⣿⣿\n|⣿⣿⣄⠀⠙⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠀⢀⣿⣿⣿⣿\n|⣿⣿⣿⣷⡀⠈⠛⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠋⠀⣴⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣶⣀⠀⠻⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠟⠁⢀⣴⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣤⣀⠀⠉⠛⠛⠛⠛⠛⠛⠛⠛⠛⠛⠋⠀⣀⣤⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿\n|⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣶⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿\n*********************************************/\n\n// #include &lt;bits/stdc++.h&gt;\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;bitset&gt;\n#include &lt;cassert&gt;\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;complex&gt;\n#include &lt;cstdio&gt;\n#include &lt;cstdlib&gt;\n#include &lt;cstring&gt;\n#include &lt;ctime&gt;\n#include &lt;deque&gt;\n#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n#include &lt;map&gt;\n#include &lt;queue&gt;\n#include &lt;random&gt;\n#include &lt;set&gt;\n#include &lt;sstream&gt;\n#include &lt;stack&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;unordered_set&gt;\n#include &lt;utility&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nusing ll = long long;\nusing Ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate &lt;typename T&gt;\nusing pair2 = pair&lt;T, T&gt;;\nusing PII = pair&lt;int, int&gt;;\nusing PLI = pair&lt;ll, int&gt;;\nusing PLL = pair&lt;ll, ll&gt;;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B)&#123; return (ull)rng() % B; &#125;\n\n#define endl &#x27;\\n&#x27;\n#define debug(x) cout &lt;&lt; #x &lt;&lt; &quot; = &quot; &lt;&lt; (x) &lt;&lt; endl\n#define abs(a) ((a) &gt;= 0 ? (a) : -(a))\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(), (x).end()\n#define mem(a, b) memset(a, b, sizeof(a))\n// #define max(a, b) ((a) &gt; (b) ? (a) : (b))\n// #define min(a, b) ((a) &lt; (b) ? (a) : (b))\n#define rep(i, a, n) for (int i = a; i &lt;= n; ++i)\n#define per(i, n, a) for (int i = n; i &gt;= a; --i)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lowbit(x) (x&amp;(-x))\n\nconst int N = 1000005; // 1e6 + 5\nconst int INF = 0x3f3f3f3f;\nconst long long LNF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-7;\nconst double PI = acos(-1.0);\nconst int MOD = 998244353;\n\n// #define int long long\n\nlong long qmi(long long m, long long k, long long p = 9e18) &#123;\n    int res = 1 % p, t = m;\n    while (k) &#123;\n        if (k&amp;1) res = res * t % p;\n        t = t * t % p, k &gt;&gt;= 1;\n    &#125;\n    return res;\n&#125;\ninline long long gcd(long long a, long long b) &#123;return b ? gcd(b, a % b) : a;&#125;\nlong long exgcd(long long a, long long b, long long &amp;x, long long &amp;y) &#123;  \n    if (!b) &#123; x = 1; y = 0; return a; &#125;  \n    int d = exgcd(b, a % b, y, x);\n    y -= (a/b) * x;  \n    return d;\n&#125;\n\nlong long Sqrt(long long N) &#123;\n    __int128 sqrtN = sqrtl(N) - 1;\n    while (sqrtN + 1 &lt;= N / (sqrtN + 1))sqrtN++;\n    return sqrtN;\n&#125;\n\n// #define int long long\nstruct SEGT &#123;\n    #define ls id &lt;&lt; 1\n    #define rs id &lt;&lt; 1 | 1\n    struct Zhenen &#123;\n        long long val, minv;\n    &#125;;\n    vector&lt;int&gt; a;\n    vector&lt;Zhenen&gt; seg;\n    SEGT(int n) : a(n + 1), seg(n * 4) &#123;&#125;\n    // 更新\n    void update(int id) &#123;\n        seg[id].val = seg[ls].val + seg[rs].val;\n        seg[id].minv = min(seg[ls].minv, seg[ls].val + seg[rs].minv);\n    &#125;\n    // 标记下传\n    void pushdown(int id) &#123;\n        \n    &#125;\n\n    void build(int id, int l, int r) &#123;\n        if(l == r) seg[id].val = a[l], seg[id].minv = min(a[l], 0);\n        else &#123;\n            int mid = l + r &gt;&gt; 1;\n            build(ls, l, mid);\n            build(rs, mid + 1, r);\n            update(id);\n        &#125;\n    &#125;\n\n    void change(int id, int l, int r, int pos, int val) &#123;\n        if(l == r) &#123;\n            seg[id].val = val, seg[id].minv = min(seg[id].val, 0ll);\n        &#125;else &#123;\n            int mid = l + r &gt;&gt; 1;\n            if(pos &lt;= mid) change(id * 2, l, mid, pos, val);\n            else change(id * 2 + 1, mid + 1, r, pos, val);\n            update(id);\n        &#125;\n    &#125;\n\n    // 查询 [ql, qr] 的区间和\n    long long query(int id, int l, int r, int ql, int qr) &#123;\n        if(l == ql &amp;&amp; r == qr) return seg[id].minv;\n        pushdown(id);\n        int mid = l + r &gt;&gt; 1;\n        if(qr &lt;= mid) return query(ls, l, mid, ql, qr);\n        else if(ql &gt; mid) return query(rs, mid + 1, r, ql, qr);\n        else return (query(ls, l, mid, ql, mid) + query(rs, mid + 1, r, mid + 1, qr));\n    &#125;\n    #undef ls\n    #undef rs\n&#125;;\n\nvoid solve();\nsigned main() &#123;\n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    // cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);\n    // int _ = 1; cin&gt;&gt; _; while(_ --)\n        solve();\n  return 0;\n&#125;\n#define int long long\n\nvoid solve() &#123;\n    int n, q, sumb = 0;\n    cin&gt;&gt; n &gt;&gt; q;\n    vector&lt;int&gt; b(n), c(n - 1);\n    SEGT tr(n);\n    for(int i = 0; i &lt; n; ++ i) cin&gt;&gt; tr.a[i + 1]; \n    for(int i = 0; i &lt; n; ++ i) cin&gt;&gt; b[i], sumb += b[i], tr.a[i + 1] -= b[i]; \n    for(int i = 0; i &lt; n - 1; ++ i) cin&gt;&gt; c[i];\n    tr.build(1, 1, n);\n    while(q --) &#123;\n        int p, x, y, z;\n        cin&gt;&gt; p &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        sumb += y - b[p - 1], b[p - 1] = y;\n        tr.change(1, 1, n, p, x - y);\n        cout &lt;&lt; tr.query(1, 1, n, 1, n) + sumb &lt;&lt;endl;\n    &#125; \n&#125; \n\n\n","slug":"Codeforces-Hello-2024-题解-CF1919","date":"2024-01-22T12:28:43.000Z","categories_index":"算法","tags_index":"算法,题解,CodeForces","author_index":"KAZEmae"},{"id":"5bd0f00513c2b7bc63e18b965d15a571","title":"CF1227D2题解","content":"原题链接\n思路当查询子序列的长度为 $k$  时，序列 $a$  中前 $k$ 大的数一定会被选中，且相同大小的数越靠前越先被选中。\n根据上面的规则对序列 $a$ 排序并离散化得到序列 $b$。我们考虑 $k$ 依次取 $1, 2, \\cdots, n$ 时的子序列，显然将序列 $b$ 依次加入即可得到 $k$ 依次取 $1, 2, \\cdots, n$ 时的子序列。\n为了快速求得子序列的第 $pos$ 个数，我们使用树状数组来维护子序列，在树状数组上二分来求第 $pos$ 个数。\n时间复杂度 $O(n\\times\\log(n))$\n代码实现#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n\ntemplate&lt;class T&gt;\nstruct BIT &#123;\n    int n;\n    vector&lt;T&gt; c;\n    // 构造函数\n    BIT(int len) : n(len), c(n + 1) &#123;&#125;\n    // 初始化\n    void init(vector&lt;int&gt; &amp;a) &#123;\n        for(int i = 1, j = 0; i &lt;= n; ++ i) &#123;\n            c[i] += a[i], j = i + ((i) &amp; (-i));\n            if(j &lt;= n) c[j] += c[i];\n        &#125;\n    &#125;\n    // 修改 a[x] += s\n    void add(int x, T s) &#123;\n        assert(x != 0);\n        for(; x &lt;= n; x += ((x) &amp; (- x)))\n            c[x] += s;\n    &#125;\n    // 查询 a[1]...a[x] 的和\n    T sum(int x) &#123;\n        assert(x &lt;= n);\n        T sum = 0;\n        for(; x; x -= ((x) &amp; (- x))) \n            sum += c[x];\n        return sum;\n    &#125;\n    // 查询 a[l]...a[r] 的和\n    T getsum(int l, int r) &#123;\n        if(r &lt; l) swap(l, r);\n        return sum(r) - sum(l - 1);\n    &#125;\n    // 查询最大的 pos, 满足 a[1]+...+a[pos] &lt;= k\n    int find(T k) &#123;\n        int l = 0;\n        for(int i = log2(n); i &gt;= 0; -- i)\n            if(l + (1 &lt;&lt; i) &lt;= n &amp;&amp; c[l + (1 &lt;&lt; i)] &lt;= k)\n                l += (1 &lt;&lt; i), k -= c[l];\n        return l;\n    &#125;\n&#125;;\n\nvoid solve();\nsigned main() &#123;\n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);\n    // cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);\n    // int _ = 1; cin&gt;&gt; _; while(_ --)\n        solve();\n  return 0;\n&#125;\n// #define int long long\n\nvoid solve() &#123;\n    int n, m, k, p;\n    cin&gt;&gt; n;\n    BIT&lt;int&gt; tr(n);\n    vector&lt;int&gt; a(n), b(n);\n    for(int i = 0; i &lt; n; ++ i) \n        cin&gt;&gt; a[i];\n\n    // 离线\n    cin&gt;&gt; m;\n    vector&lt;int&gt; ans(m);\n    vector&lt;vector&lt;pair&lt;int, int&gt; &gt; &gt; q(n);\n    for(int i = 0; i &lt; m; ++ i) &#123;\n        cin&gt;&gt; k &gt;&gt; p;\n        q[k - 1].push_back(&#123;p, i&#125;);\n    &#125;\n\n    // 排序, 离散化\n    for(int i = 0; i &lt; n; ++ i) b[i] = i;\n    sort(b.begin(), b.end(), [&amp;](int i, int j) &#123;\n        return (a[i] &gt; a[j] || (a[i] == a[j] &amp;&amp; i &lt; j));\n    &#125;);\n\n    // 查询\n    for(int i = 0; i &lt; n; ++ i) &#123;\n        tr.add(b[i] + 1, 1);\n        for(auto j : q[i]) \n            ans[j.second] = a[tr.find(j.first - 1)];\n    &#125;\n\n    for(auto i : ans) cout &lt;&lt; i &lt;&lt;endl;\n&#125;\n\n","slug":"CF1227D2题解","date":"2024-01-16T12:13:14.000Z","categories_index":"算法","tags_index":"算法,数据结构,数组数组","author_index":"KAZEmae"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2024-01-08T14:42:00.000Z","categories_index":"","tags_index":"","author_index":"KAZEmae"},{"id":"04f8e9ebd29b313fc8963f63caba7d79","title":"洛谷[P1111] 修复公路","content":"原题链接\n原题：题目背景A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。\n题目描述给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。\n输入格式第 $1$ 行两个正整数 $N,M$。下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间t时能修复完成这条公路。\n输出格式如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。\n数据范围$1\\leq x, y\\leq N \\le 10 ^ 3$，$1\\leq M, t \\le 10 ^ 5$。\n算法：[[并查集]]思路：\n题目没有提及，但看样例可知，所有公路是同时开工的。\n我们按时间排序，先判断时间用的更少的。\n将两个相连的村庄放入同一个集合。\n若联通集合中元素数目等于村庄数，则所有村庄已联通，输出现在的时间即可。\n若修完所有的路，集合中元素数仍然小于村庄数，则说明无法所有村庄实现联通。\n\n实现：排序：因为对 $t$ 排序， 要 $x, y$ 随 $t$ 一起移动，可使用结构体，（或者使用pair&lt;int, pair&lt;int, int&gt; &gt;  $first存储 t，second存储x,y$ ）\n元素数统计：定义 size[] 数组\n\n全部初始化为$1$。\n如果两个村庄合并，则将新集合的祖宗节点的size[]大小更改为原先两个集合的元素数之和。\n\n实例代码#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nusing ll = long long;\n#define endl &quot;\\n&quot;\n//#define int long long\n\nconst int N = 100005; // 1e6+5\n\nstruct LGY &#123;\n    int x, y, t;\n&#125;;\n// 使sort按t排序\nbool cmp (LGY a, LGY b) &#123;\n    return a.t &lt; b.t;\n&#125;\n// p数组存储父节点， siz数组存储集合元素个数\nint p[N], siz[N];\nvector&lt;LGY&gt; a;\n// 查找祖宗节点函数，并路径压缩\nint find(int x) &#123;\n    return x == p[x] ? p[x] : p[x] = find(p[x]);\n&#125;\nsigned main(void) &#123;\n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n    int n, m, dx, ans = 0;\n    LGY z;\n    cin&gt;&gt; n &gt;&gt; m;\n    // 初始化p数组和siz数组\n    for(int i = 1; i &lt;= n; i++)\n        p[i] = i, siz[i] = 1;\n    // 输入\n    for(int i = 1; i &lt;= m; i++) &#123;\n        cin&gt;&gt; z.x &gt;&gt; z.y &gt;&gt; z.t;\n        a.push_back(z);\n    &#125;\n    // 排序\n    sort(a.begin(), a.end(), cmp);\n    // 遍历每条路\n    for(auto i:a) &#123;\n\t    //如果 x, y 未联通\n        if(find(i.x) != find(i.y)) &#123;\n\t        // 将 x, y 集合的元素数相加\n            siz[find(i.y)] += siz[find(i.x)];\n            // 将 x 集合的祖宗节点指向 y 集合的祖宗节点\n            p[find(i.x)] = find(i.y);\n            // 记录元素个数\n            dx = siz[find(i.y)];\n            // 更新答案\n            ans = i.t;\n        &#125;\n        // 如果所有村庄联通则脱出循环\n        if(dx == n) break;\n    &#125;\n    // 判断是否所有村庄联通\n    if(dx == n) cout&lt;&lt; ans ;\n    else cout&lt;&lt; -1;\n    return 0;\n&#125;\n","slug":"洛谷-P1111-修复公路","date":"2024-01-08T13:10:39.000Z","categories_index":"算法","tags_index":"算法,数据结构,题解,洛谷","author_index":"KAZEmae"},{"id":"c18469ab20e7b093d36b4a61728d07eb","title":"并查集","content":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。\n作用：并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）\n实现初始化将每个节点的祖宗节点指向自己，故祖宗节点的特质是它的父节点是自己，p[x] == x\nfor(int i = 1; i &lt;= n; i++) \n\tp[i] = i;\n查首先我们需要定义一个数组：int p[]; 用于记录每个节点的父节点是哪个节点（数组长度依题意而定）。这个数组记录了每个人的父节点是谁。路径压缩：每次查询将沿路的节点全部指向父节点，这样操作之后每次查询的复杂度为$O(1)$\n//写法1：\nint find(int x) &#123;\n    return x == p[x] ? p[x] : p[x] = find(p[x]); \n    // 如果当前节点不是祖宗节点则查找当前节点的父节点，一直递归到祖宗节点\n    //并把沿路所有节点指向祖宗节点\n&#125;\n//写法2：\nint find(int x) &#123;\n\tif(x != p[x]) p[x] = find(p[x]);\n\treturn p[x];\n&#125;\n并将 $x,y$ 各自所属的集合合并，查询 $x,y$ 各自的祖宗节点，然后将 $y$ 的祖宗节点指向 $x$ 的祖宗节点。\np[find(y)] = find(x);\n// 将 y 的祖宗节点指向 x 的祖宗节点\n","slug":"并查集","date":"2024-01-08T13:06:04.000Z","categories_index":"算法","tags_index":"算法,Cpp","author_index":"KAZEmae"},{"id":"afbdc662f7a3047fa9981dc983cb9e4b","title":"对拍器","content":"对拍是什么对拍，是一个比较实用的工具。它能够非常方便地对于两个程序的输出文件进行比较，可以帮助我们实现一些自动化的比较输出结果的问题。\n众所周知，几乎每一道编程题目，都会有某种正解能拿到满分；当我们想不出正解时，我们往往可以打暴力代码来获取部分分数。\n但是，当我们觉得有思路写正解，但又担心自己正解写的不对，而恰好，我们又有一个能够暴力骗分的代码。这个时候就可以用到对拍。 暴力骗分代码必须保证正确性，只是超出时间限制，不能出现答案错误的情况。\n这样，我们可以造多组数据，让暴力骗分的程序跑一遍，再让我们自己写的正解跑一遍，二者进行多次对比。如果多组数据都显示二者的输出结果一样，那么这个正解大概率没问题。相反地，如果两组数据不同，我们就找到了一组错误数据，方便调试，找到正解哪里出了问题。\n对拍的实现准备代码首先我们需要两份代码，一份是自己的解法，一份是暴力解法或者 std 以及数据生成代码。我们以 $A + B$ 为例：\n\n自己的解法：#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \n#define endl &quot;\\n&quot;  \n  \nvoid solve() &#123;  \n    int a, b;  \n    cin&gt;&gt; a &gt;&gt; b;  \n    cout&lt;&lt; a + b &lt;&lt;endl;  \n&#125;  \nsigned main () &#123;  \n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);  \n//    int t; cin&gt;&gt; t; while(t --)  \n        solve();  \n&#125;\n暴力解法：#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \n#define endl &quot;\\n&quot;  \n#define int long long  \n  \nvoid solve() &#123;  \n    int a, b;  \n    long long ans = 0;  \n    cin&gt;&gt; a &gt;&gt; b;  \n    for(int i = 0; i &lt; a; ++ i) ans ++;  \n    for(int i = 0; i &lt; b; ++ i) ans ++;  \n    cout&lt;&lt; ans &lt;&lt;endl;  \n&#125;  \nsigned main () &#123;  \n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);  \n//    int t; cin&gt;&gt; t; while(t --)  \n        solve();  \n&#125;\n数据生成代码：#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \n#define endl &quot;\\n&quot;  \n  \n// 随机数生成函数  \nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());  \nlong long myRand(long long B) &#123;  \n    return (unsigned long long)rng() % B; &#125;  \n  \nsigned main () &#123;  \n    std::ios::sync_with_stdio(false), cin.tie(nullptr), cout.tie(nullptr);  \n    // 生成并输出数据  \n    cout&lt;&lt; myRand(1500000000) &lt;&lt; &quot; &quot; &lt;&lt; myRand(1500000000) &lt;&lt;endl;  \n&#125;\n\n准备程序和文件将自己的解法程序编译生成的 .exe 文件，暴力解法编译生成的 .exe 文件和数据生成代码编译生成的 .exe 文件放到同一文件夹下。并创建文件 in.txt，std.txt, baoli.txt 用于存放数据和输出结果。\n对拍代码标准输入输出代码标准输入输出指的是：两份基本代码和数据生成代码里不含文件输入输出操作，如 freopen 等。在这里，我们需要用到一些文件的读写符号。（需用到 &lt;cstdlib&gt; 库）system(&quot;A.exe &gt; A.txt&quot;) 指的是运行 A.exe，把结果输出（&gt;）到 A.txt 中。system(&quot;B.exe &lt; A.txt &gt; C.txt&quot;) 指的是运行 B.exe，从 A.txt 中读入（&lt;）数据，把结果输出（&gt;）到 C.txt 中。system(&quot;fc A.txt B.txt&quot;) 指的是比较 A.txt 和 B.txt ，如果两个文件里的数据相同返回 $0$，不同返回 $1$。\n那么，我们就可以执行这一操作来实现对拍：\n\n先让数据生成器输出数据。 system(&quot;data.exe &gt; in.txt&quot;)\n然后用这个数据跑一遍暴力代码，输出结果。 system(&quot;baoli.exe &lt; in.txt &gt; baoli.txt&quot;)\n再用这个数据跑一遍你写的正解代码，输出结果。 system(&quot;std.exe &lt; in.txt &gt; std.txt&quot;)\n把两个结果相比较，判断是不是一样的。 system(&quot;fc std.txt baoli.txt&quot;)\n\n对拍程序代码：#include &lt;iostream&gt;  \n#include &lt;cstdio&gt;  \n#include &lt;windows.h&gt;  \n#include &lt;cstdlib&gt;  \n#include &lt;ctime&gt;  \nusing namespace std;  \n  \nint main() &#123;  \n    // 对拍次数  \n    int n = 100000, i = 1;     \n    for (i = 1; i &lt;= n; ++ i) &#123;  \n        // 生成数据  \n        system(&quot;date.exe &gt; in.txt&quot;);         // 运行自己的解法  \n        system(&quot;std.exe &lt; in.txt &gt; std.txt&quot;);         // 记录暴力开始时间  \n        double begin = clock();         // 运行暴力程序  \n        system(&quot;baoli.exe &lt; in.txt &gt; baoli.txt&quot;);         // 计算暴力用时  \n        double t = clock() - begin;         // 如果两次结果不一样  \n        if (system(&quot;fc std.txt baoli.txt&quot;)) &#123;             \n\t        printf(&quot;测试点#%d Wrong Answer\\n&quot;, i);  \n            // 退出程序  \n            break;  \n        // 如果暴力程序超过 1 秒, 输出超时, 请根据不同题目自行修改或删除, 单位(ms)  \n        &#125; else if (t &gt; 1000) &#123;  \n            printf(&quot;测试点#%d Time Limited Exceeded 用时 %.0lfms\\n&quot;, i, t);  \n        &#125;else             \n\t        printf(&quot;测试点#%d Accepted 用时%.0lfms\\n&quot;, i, t);  \n    &#125;  \n    printf(&quot;\\n共 %d 组测试数据\\n&quot;, i);  \n    Sleep(1000); //休眠1秒  \n&#125;\n\n将对拍代码编译生成的 .exe 放入之前创建的文件夹运行即可\n当对拍器测到自己的解法和暴力代码运行结果不一样时会终止对拍，此时打开 in.txt， std.txt，baoli.txt 里面存放的就是运行结果不一样那次的数据，打开查看即可。对拍器会计算 baoli.exe 的运行时间，默认是超过 $1000 \\ ms$ 判为超时，请根据自己需要进行修改或删除。\n对拍结果$e.g:$\n正在比较文件 std.txt 和 BAOLI.TXT\nFC: 找不到差异\n\n测试点#1 Accepted 用时16ms\n正在比较文件 std.txt 和 BAOLI.TXT\nFC: 找不到差异\n\n测试点#2 Accepted 用时21ms\n正在比较文件 std.txt 和 BAOLI.TXT\n***** std.txt\n-1797548159\n***** BAOLI.TXT\n2497419137\n*****\n\n测试点#3 Wrong Answer\n\n共 3 组测试数据\n\n--------------------------------\nProcess exited after 1.236 seconds with return value 0 (0 ms cpu time, 4276 KB mem used).\nPress ANY key to exit...\n\n可以看见在第 $3$ 次测试 std.exe 和 baoli.txt 的结果不一样了。打开查看数据，然后就可以开始快乐 $debug$ 了。\n","slug":"对拍器","date":"2024-01-08T13:06:00.000Z","categories_index":"算法","tags_index":"算法,工具,Cpp","author_index":"KAZEmae"},{"id":"0fe35e38e770f16f9b8cdba4cf1ece54","title":"如何优雅地用 Sublime Text 刷题（C/C++）","content":"LastEditTime: 2023-07-08 12:31:02\n基本都是抄来改的，就当图个备份。(bushi)\n0x01下载 Sublime TextSublime Text 官网\n0x02 安装MinGW编译器我们选择 mingw64。注意安装的路径不能包含中文、空格以及其他非ASCII字符！！！\n我使用小熊猫DevC++自带的MinGw。\n0x03 设置环境变量任务栏搜索 &#x3D;&#x3D;高级系统设置&#x3D;&#x3D; ，选择&#x3D;&#x3D;用户的环境变量&#x3D;&#x3D;，双击&#x3D;&#x3D;Path变量&#x3D;&#x3D;，点击&#x3D;&#x3D;新建&#x3D;&#x3D;，输入 mingw64的路径\\bin 。\n检验是否设置成功win+R打开运行，输入 cmd 运行。输入 gcc、g++ 查看是否配置成功。\n0x04 配置 Sublime Text汉化及插件安装方法插件管理系统\n\nCtrl+Shift+P打开sublime的命令面板。\n\n输入 install package control 回车进行安装。\n\n等待左下角的等号跑完\n\n这是安装好了插件管理系统\n\n\n汉化\n\nCtrl+Shift+P打开sublime的命令面板。\n\n输入 pcip 打开回车，打开插件安装界面。\n\n输入 chinese 安装中文插件\n\n\n个性化配置这里我以我的需求为例，我想要在某个文件夹下面创建很多个xxx.cpp文件（一看就是刷题狗呢）然后可以一键编译运行，产生的编译文件（xxx.exe）不会污染原目录下的cpp文件。并且可以知道程序运行时间。\n首先我想形成这样一个目录结构：\nMyProject  \n|  \n|____code  \n|   |___test1.cpp  \n|   |___test2.cpp  \n|   |___test.c  \n|   |___test.py  \n|  \n|____bin  \n|   |___test.exe  \n|   |___test1.exe  \n|   |___test2.exe  \n|  \n|____data  \n    |___in.txt  \n    |___out.txt\n\n\n先把上面的文件夹和 in&#x2F;out.txt 文件创建好\n\n先把MyProject（名字随便取）拖到sublime里面去。\n\n再在code里面随便写一个test.cpp\n\n工具 -&gt; 编译系统 -&gt; 新建编译系统，将下面的代码复制过去，保存。\n&#123;  \n    // 写上你自己的 MinGW 地址  \n    &quot;path&quot;: &quot;D:/Code/RedPanda-Cpp/MinGW64/bin&quot;,  \n    // build only  \n    &quot;shell_cmd&quot;: &quot;g++ -std=c++2a -g -Wall -o2 \\&quot;$&#123;file&#125;\\&quot; -o \\&quot;$&#123;file_path&#125;/../bin/$&#123;file_base_name&#125;\\&quot;&quot;,  \n    // check the file name using regex  \n    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,  \n    &quot;encoding&quot;: &quot;GBK&quot;,  \n    // doesn&#x27;t matter if I use full path  \n    &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,  \n    // only C and Cpp files can use this sublime-build file  \n    &quot;selector&quot;: &quot;source.c, source.c++&quot;,  \n   \n    &quot;variants&quot;:  \n    [  \n        &#123;  \n            &quot;name&quot;: &quot;Run&quot;,  \n            &quot;shell_cmd&quot;: &quot;g++ -std=c++2a -g -Wall -o2 \\&quot;$&#123;file&#125;\\&quot; -o \\&quot;$&#123;file_path&#125;/../bin/$&#123;file_base_name&#125;\\&quot; &amp;&amp; $&#123;file_path&#125;/../bin/timer \\&quot;$&#123;file_path&#125;/../bin/$&#123;file_base_name&#125;\\&quot; &lt; $&#123;file_path&#125;/../data/in.txt &gt; $&#123;file_path&#125;/../data/out.txt&quot;  \n        &#125;  \n    ]  \n&#125;\n将下面的代码编译，将生成的.exe文件重命名为 timer.exe，放入 MyProject&#x2F;bin 文件夹\n#include &lt;cstdio&gt;  \n#include &lt;cstdlib&gt;  \n#include &lt;ctime&gt;  \n#include &lt;windows.h&gt;  \nusing namespace std;  \n   \nint main(int argc, char** argv)  \n&#123;  \n    clock_t begin = clock();  \n    system(argv[1]);  \n    double used = 1000.0 * double(clock() - begin) / CLOCKS_PER_SEC - 200.0;  \n    if (used &lt; 0) used = 0.0;  \n    printf(&quot;\\n\\n------------------------------\\n&quot;);  \n    printf(&quot;Time used: %.2lf ms.\\n&quot;, used);  \n    return 0;  \n&#125;\n\n现在在code.cpp中写入程序，编译时选择刚刚新建的编译系统，之后直接Ctrl+B即可。窗口布局也可调整如下更方便。![[image-20230708131218280.png]]\nsublime偏好设置将下面的代码复制到 Preferences-&gt;Settings。\n&#123;  \n    &quot;font_size&quot;: 14,  \n    &quot;ignored_packages&quot;: [  \n        &quot;Vintage&quot;,  \n    ],  \n    // 设置tab的大小为4  \n    &quot;tab_size&quot;: 4,  \n    // 使用空格代替 Tab  \n    &quot;translate_tabs_to_spaces&quot;: true,  \n    // 使用默认字体 Monaco  \n    &quot;font_face&quot;: &quot;Monaco&quot;,  \n    // 失去光标自动保存  \n    &quot;save_on_focus_lost&quot;: true,  \n    // 添加行宽标尺  \n    &quot;rulers&quot;: [  \n        100  \n    ],  \n    // 显示空白字符  \n    &quot;draw_white_space&quot;: &quot;all&quot;,  \n    // 保存时自动去除行末空白  \n    &quot;trim_trailing_white_space_on_save&quot;: &quot;all&quot;,  \n    // 保存时自动增加文件末尾换行  \n    &quot;ensure_newline_at_eof_on_save&quot;: true,  \n    // 默认编码格式  \n    &quot;default_encoding&quot;: &quot;UTF-8&quot;,  \n    // 不检查更新  \n    &quot;update_check&quot;: false,  \n    // 把光标的样式从闪烁变成淡入淡出  \n    // 其余的选项还有&quot;smooth&quot;, &quot;phase&quot;, &quot;blink&quot;, &quot;wide&quot;， &quot;solid&quot;.  \n    &quot;caret_style&quot;: &quot;phase&quot;,  \n    // 高亮当前行  \n    &quot;highlight_line&quot;: true,  \n    // 增加行间距  \n    &quot;line_padding_bottom&quot;: 1,  \n    &quot;line_padding_top&quot;: 1,  \n    // 一直显示代码折叠箭头  \n    &quot;fade_fold_buttons&quot;: false,  \n    // 排除这些文件夹，搜索和侧边栏都不会显示  \n    &quot;folder_exclude_patterns&quot;: [  \n        &quot;*.dSYM&quot;,  \n    ],  \n    // 排除这些文件，搜索和侧边栏都不会显示  \n    &quot;file_exclude_patterns&quot;: [  \n        &quot;.DS_Store&quot;,  \n        &quot;.clang-format&quot;,  \n        &quot;.clang-tidy&quot;,  \n    ],  \n&#125;\n快捷键设置总是按 Ctrl+B 编译太麻烦？没关系，Sublime Text支持自定义快捷键。\n请前往“_首选项-快捷键设置_”找到&#123; &quot;keys&quot;: [&quot;ctrl+b&quot;], &quot;command&quot;: &quot;build&quot; &#125;这一行，把前面的”ctrl+b”尽情地改成自己习惯的按键。（为避免冲突，建议新建一个.sublime-keymap –User，将改后的代码复制进去单独保存）\n\n\n\n\n\n\n\n\n\n常用操作：\n\n寻找：ctrl+F\n\n替换：ctrl+H\n\n命令窗口：ctrl+shift+P\n\n框选所有相同变量名：Alt+F3\n\n注释：ctrl+&#x2F;\n\n在多个代码标签中切换：ctrl+tab\n\n分屏：Alt+shift+数字（数字为键盘上面那一行，表示为分多少块屏）\n\n多行折叠：ctrl+J （毁别人代码的神器）\n\n折叠代码：ctrl+shift+[\n\n展开代码：ctrl+shift+]\n\n\n优雅刷题必备插件 cppFastOlympicCoding使用刚刚安装中文包一样的方法安装 FastOlympicCoding\n\n\n\n\n\n\n\n\n\nCppFastOlympicCoding插件提供了以下功能。\n\n测试管理器。 在测试管理器的帮助下，我们可以轻松添加、编辑和删除测试。\n\nStressTesting。 StressTesting意味着我们可以测试我们的程序，找到它不工作的测试。\n\nCppLint。 我们可以在设置中编辑Cpplint的属性。\n\n调试器。 它为OSX提供调试功能。\n\n类的补全。 对于模板的替换，将字符写成类。\n\n竞赛设置。 它是专门为竞争性编程设计的。\n\n\n安装完成后，打开菜单 -&gt; 首选项 -&gt; Package-Setting -&gt; FastOlympicCoding\n将下面的配置覆盖左侧设置：\n&#123;  \n    // enable/disable lint  \n    &quot;lint_enabled&quot;: true,  \n      \n    // lint style properties  \n    &quot;lint_error_region_scope&quot;: &quot;invalid.illegal&quot;,  \n    // &quot;lint_error_region_scope&quot;: &quot;variable.c++&quot;,  \n    &quot;lint_warning_region_scope&quot;: &quot;constant&quot;,  \n  \n    &quot;algorithms_base&quot;: null,  \n  \n    // run settings:  \n    // &quot;&#123;file&#125;&quot;: file name  \n    // &quot;&#123;source_file&#125;&quot;: relative path to file  \n    // &quot;&#123;source_file_dir&#125;&quot;: relative path to file directory  \n    // &quot;&#123;file_name&#125;&quot;: file basename  \n    &quot;run_settings&quot;: [  \n        &#123;  \n            &quot;name&quot;: &quot;C++&quot;,  \n            &quot;extensions&quot;: [&quot;cpp&quot;],  \n            &quot;compile_cmd&quot;: &quot;g++ \\&quot;&#123;source_file&#125;\\&quot; -std=c++11 -o \\&quot;&#123;source_file_dir&#125;/../bin/&#123;file_name&#125;.exe\\&quot;&quot;,  \n            &quot;run_cmd&quot;: &quot;\\&quot;&#123;source_file_dir&#125;/../bin/&#123;file_name&#125;.exe\\&quot; &#123;args&#125; -debug&quot;,  \n  \n            &quot;lint_compile_cmd&quot;: &quot;g++ -std=gnu++11 \\&quot;&#123;source_file&#125;\\&quot; -I \\&quot;&#123;source_file_dir&#125;\\&quot;&quot;  \n        &#125;,  \n  \n        &#123;  \n            &quot;name&quot;: &quot;Python&quot;,  \n            &quot;extensions&quot;: [&quot;py&quot;],  \n            &quot;compile_cmd&quot;: null,  \n            &quot;run_cmd&quot;: &quot;python \\&quot;&#123;source_file&#125;\\&quot;&quot;  \n        &#125;,  \n          \n        &#123;  \n            &quot;name&quot;: &quot;Java&quot;,  \n            &quot;extensions&quot;: [&quot;java&quot;],  \n            &quot;compile_cmd&quot;: &quot;javac -J-Dfile.encoding=utf8 -d \\&quot;&#123;source_file_dir&#125;\\&quot; \\&quot;&#123;source_file&#125;\\&quot;&quot;,  \n            &quot;run_cmd&quot;: &quot;java -classpath \\&quot;&#123;source_file_dir&#125;\\&quot; \\&quot;&#123;file_name&#125;\\&quot;&quot;  \n        &#125;  \n    ],  \n  \n    // time limit for stress  \n    &quot;stress_time_limit_seconds&quot;: 2,  \n  \n    // enable/disable complete  \n    &quot;cpp_complete_enabled&quot;: true,  \n  \n    // class completion settings  \n    &quot;cpp_complete_settings&quot;: &#123;  \n        &quot;classes&quot;: &#123;  \n            &quot;int&quot;: &#123;  \n                &quot;template_size&quot;: 0,  \n            &#125;,  \n  \n            &quot;char&quot;: &#123;  \n                &quot;template_size&quot;: 0  \n            &#125;,  \n  \n            &quot;string&quot;: &#123;  \n                &quot;template_size&quot;: 0,  \n            &#125;,  \n  \n            &quot;pair&quot;: &#123;  \n                &quot;template_size&quot;: 2,  \n            &#125;,  \n  \n            &quot;vector&quot;: &#123;  \n                &quot;template_size&quot;: 1  \n            &#125;,  \n  \n            &quot;bool&quot;: &#123;  \n                &quot;template_size&quot;: 0  \n            &#125;,  \n  \n            &quot;ll&quot;: &#123;  \n                &quot;template_size&quot;: 0  \n            &#125;,  \n  \n            &quot;double&quot;: &#123;  \n                &quot;template_size&quot;: 0  \n            &#125;,  \n  \n            &quot;set&quot;: &#123;  \n                &quot;template_size&quot;: 1,  \n                &quot;bind&quot;: &quot;S&quot;  \n            &#125;,  \n  \n            &quot;map&quot;: &#123;  \n                &quot;template_size&quot;: 2  \n            &#125;  \n        &#125;,  \n  \n        &quot;dont_expand&quot;: [  \n            &quot;pii&quot;  \n        ]  \n    &#125;,  \n  \n    // closing sidebar when executing  \n    &quot;close_sidebar&quot;: false,   \n  \n    // tests files dir  \n    &quot;tests_relative_dir&quot;: &quot;&quot;  \n&#125;\n\n\n\n\n\n\n\n\n\n快捷键：\nmacOS系统下：\n\n编译并运行：ctrl+b\n\n创建新的测试：ctrl+enter\n\n终止进程：ctrl+c\n\n使用调试器运行：ctrl+shift+b\n\n删除测试：ctrl+d\n\n交换测试位置：ctrl+super+up&#x2F;ctrl+super+down\n\n关闭&#x2F;打开右侧面板：cmd+k, cmd+p\n\n\nLinux和Windows系统下：\n\n编译并运行：ctrl+alt+b\n\n创建新的测试：ctrl+enter\n\n终止进程：ctrl+x\n\n使用调试器运行：ctrl+shift+b\n\n删除测试：ctrl+d\n\n交换测试位置：ctrl+shift+up&#x2F;ctrl+shift+down\n\n关闭&#x2F;打开右侧面板：ctrl+k, ctrl+p\n\n\nSublime Text 插件推荐SideBarEnhancementsSideBarEnhancements是sublime的加强侧边栏插件，在View—side bar菜单中可以控制显示或隐藏侧边栏（下图），我们可以将一个项目文件夹拖动到侧边栏中，就可以很方便地对目录下的文件进行可视化管理。\nBracket Highlighter括号匹配，可匹配[], (), {}, “”, ”,，高亮标记，便于查看起始和结束标记\nAll Autocomplete自动补全\nStatus Bar Time在左下角显示时间\nSublimeAStyleFormatter代码格式化，快捷键 ctrl + alt + f\n个性化插件——插入时间在代码中快速插入时间，实现按下 f1 可插入时间\n工具 -&gt; 插件开发 -&gt; 新建插件，将下面的代码复制过去。\nimport datetime  \nimport sublime_plugin  \nclass AddCurrentTimeCommand(sublime_plugin.TextCommand):  \n    def run(self, edit):  \n        self.view.run_command(&quot;insert_snippet&quot;,   \n            &#123;  \n                &quot;contents&quot;: &quot;%s&quot; % datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)   \n            &#125;  \n        )\n需要配置快捷键：首选项 -&gt; 快捷键设置\n[  \n    &#123;  \n        &quot;command&quot;: &quot;add_current_time&quot;,  \n        &quot;keys&quot;: [  \n            &quot;f1&quot;  \n        ]  \n    &#125;  \n]\n\n代码模板工具 -&gt; 插件开发 -&gt; 新建代码片段\n\n普通模板\n&lt;snippet&gt;  \n    &lt;content&gt;&lt;![CDATA[  \n/**  \n * @Author   \n * @DateTime   \n */  \n#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \n//#define int long long  \n\ntypedef long long ll;  \ntypedef pair&lt;int, int&gt; PII;  \n#define endl &quot;\\n&quot;  \n  \nconst int N = 1000005; // 1e6 + 5  \n  \nsigned main () &#123;  \n    std::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);  \n  \n&#125;  \n  \n]]&gt;&lt;/content&gt;  \n    &lt;!-- 唤醒词 --&gt;  \n    &lt;tabTrigger&gt;acm&lt;/tabTrigger&gt;  \n    &lt;!-- 描述信息，可选 --&gt;  \n    &lt;description&gt;C/C++ 基础头文件&lt;/description&gt;  \n    &lt;!-- 对什么文件生效，下为C/C++ --&gt;  \n    &lt;scope&gt;source.c, source.c++&lt;/scope&gt;  \n&lt;/snippet&gt;\n\nCodeForces 模板\n\n\n&lt;snippet&gt;  \n\t&lt;content&gt;&lt;![CDATA[  \n/**  \n * @Author   \n * @DateTime   \n */  \n#include &lt;bits/stdc++.h&gt;  \nusing namespace std;  \ntypedef long long ll;  \ntypedef pair&lt;int, int&gt; PII;  \n#define endl &quot;\\n&quot;  \n  \n//#define int long long  \nconst int N = 1000005; // 1e6 + 5  \n  \nvoid solve() &#123;  \n  \n&#125;  \nsigned main () &#123;  \n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);  \n\tint t; cin&gt;&gt; t; while(t --)  \n\t\tsolve();  \n&#125;  \n  \n]]&gt;&lt;/content&gt;  \n\t&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;  \n\t&lt;tabTrigger&gt;cf&lt;/tabTrigger&gt;  \n\t&lt;!-- 描述信息，可选 --&gt;  \n   \t&lt;description&gt;针对codeforces 定制的 C/C++ 基础头文件&lt;/description&gt;  \n\t&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;  \n\t&lt;scope&gt;source.c, source.c++&lt;/scope&gt;  \n&lt;/snippet&gt;\n3.普通模板\n&lt;snippet&gt;  \n\t&lt;content&gt;&lt;![CDATA[  \n/**  \n * @Author   \n * @DateTime   \n */  \n//#include&lt;bits/stdc++.h&gt;  \n#include &lt;algorithm&gt;  \n#include &lt;bitset&gt;  \n#include &lt;complex&gt;  \n#include &lt;deque&gt;  \n#include &lt;exception&gt;  \n#include &lt;fstream&gt;  \n#include &lt;functional&gt;  \n#include &lt;iomanip&gt;  \n#include &lt;ios&gt;  \n#include &lt;iosfwd&gt;  \n#include &lt;iostream&gt;  \n#include &lt;istream&gt;  \n#include &lt;iterator&gt;  \n#include &lt;limits&gt;  \n#include &lt;list&gt;  \n#include &lt;locale&gt;  \n#include &lt;map&gt;  \n#include &lt;memory&gt;  \n#include &lt;new&gt;  \n#include &lt;numeric&gt;  \n#include &lt;ostream&gt;  \n#include &lt;queue&gt;  \n#include &lt;set&gt;  \n#include &lt;sstream&gt;  \n#include &lt;stack&gt;  \n#include &lt;stdexcept&gt;  \n#include &lt;streambuf&gt;  \n#include &lt;string&gt;  \n#include &lt;typeinfo&gt;  \n#include &lt;utility&gt;  \n#include &lt;valarray&gt;  \n#include &lt;vector&gt;  \n#include &lt;unordered_map&gt;  \n#include &lt;unordered_set&gt;  \n#include &lt;random&gt;  \n#include &lt;tuple&gt;  \n//#if __cplusplus &gt;= 201103L  \n// #include &lt;array&gt;  \n// #include &lt;atomic&gt;  \n// #include &lt;chrono&gt;  \n// #include &lt;condition_variable&gt;  \n// #include &lt;forward_list&gt;  \n// #include &lt;future&gt;  \n// #include &lt;initializer_list&gt;  \n// #include &lt;mutex&gt;  \n// #include &lt;ratio&gt;  \n// #include &lt;regex&gt;  \n// #include &lt;scoped_allocator&gt;  \n// #include &lt;system_error&gt;  \n// #include &lt;thread&gt;  \n// #include &lt;typeindex&gt;  \n// #include &lt;type_traits&gt;  \n  \nusing namespace std;  \nusing ll = long long;  \nusing ld = long double;  \nusing uint = unsigned int;  \nusing ull = unsigned long long;  \nusing PII = pair&lt;int, int&gt;;  \nusing PLI = pair&lt;ll, int&gt;;  \nusing PLL = pair&lt;ll, ll&gt;;  \n  \n#define mem(a,b) memset(a,b,sizeof a)  \n#define endl &quot;\\n&quot;  \n#define lowbit(a) ((a)&amp;-(a))  \n#define random(a,b) ((a)+rand()%((b)-(a)+1))  \n#define clear(); std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);  \n#define debug(x) cout &lt;&lt; #x &lt;&lt; &#x27; &#x27; &lt;&lt; &#x27;=&#x27; &lt;&lt; &#x27; &#x27; &lt;&lt; (x) &lt;&lt; endl  \n#define abs(a) ((a) &gt;= 0 ? (a) : -(a))  \n#define sz(x) ((int)(x).size())  \n#define all(x) (x).begin(), (x).end()  \n#define mem(a, b) memset(a, b, sizeof(a))  \n#define max(a, b) ((a) &gt; (b) ? (a) : (b))  \n#define min(a, b) ((a) &lt; (b) ? (a) : (b))  \n#define fr(i, a, n) for (int i = a; i &lt;= n; ++i)  \n#define rf(i, n, a) for (int i = n; i &gt;= a; --i)  \n#define pb push_back  \n#define mp make_pair  \n#define fi first  \n#define se second  \n  \n#define int long long  \n  \nconst double eps = 1e-7;  \nconst double PI = acos( -1 );  \nconst int INF = 0x3f3f3f3f;  \nconst int MOD = 1e9 + 7;  \nconst int N = 2e6+10;  \n  \nsigned main()&#123;  \n\t//clear();  \n\t  \n&#125;  \n  \n]]&gt;&lt;/content&gt;  \n\t&lt;!-- Optional: Set a tabTrigger to define how to trigger the snippet --&gt;  \n\t&lt;tabTrigger&gt;wam&lt;/tabTrigger&gt;  \n\t&lt;!-- 描述信息，可选 --&gt;  \n   \t&lt;description&gt;C/C++ 头文件 附带宏定义&lt;/description&gt;  \n\t&lt;!-- Optional: Set a scope to limit where the snippet will trigger --&gt;  \n\t&lt;scope&gt;source.c, source.c++&lt;/scope&gt;  \n&lt;/snippet&gt;\n","slug":"如何优雅地用-Sublime-Text-刷题（C-C","date":"2024-01-08T13:04:24.000Z","categories_index":"算法","tags_index":"工具,Cpp","author_index":"KAZEmae"},{"id":"d26940bc311bdaabb8d1c2107d93235d","title":"01背包","content":"01背包每件物品只能装一次\n朴素二维动态规划\n$dp[i][j]：$$i$表示当前对第$i$个物品判断，$j$表示当前背包最大容量为$j$，$dp[i][j]$ 表示第$i$个物品最大空间为$j$时背包能装最大价值。\n$v[i]$表示第$i$个物品的体积。\n$w[i]$表示第$i$个物品的价值。\n\n分析：\n\n当 $j-v[i] \\ge 0$ 时：$$dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-v[i]] + w[i])$$\n当 $j-v[i] &lt; 0$ 时：$$dp[i][j] &#x3D; dp[i - 1][j]$$\n\n滚动数组// 滚动数组\n    \n    vector&lt;int&gt; dp(m + 5), g(m + 5);\n    \n    // dp 储存第i - 1行, g 储存第i行\n\n    for(int i = 1; i &lt;= n; i++) &#123;\n        for(int j = 1; j &lt;= m; j++) &#123;\n            if(j &lt; v[i])\n                g[j] = dp[j];\n            else \n                g[j] = max(dp[j], dp[j - v[i]] + w[i]);\n        &#125;\n        dp = g;\n    &#125; \n    cout&lt;&lt; dp[m] &lt;&lt;endl;\n\n\n\n状态压缩：一维动态规划\n首先其实可以发现整个转移方程中对于 $i$ 这一维，只用到了 $i -1$， 所以我们其实并不需要记录所有的 $dp[i][..]$，相反只需要用单个变量记录即可（滚动数组）。\n去除$i$这一维后，我们碰到了一些问题:\n对于$j$ 这一维因为 $j - v[i] &lt; j$，所以实际上 $dp[j - v[i]]$ 这个状态已经计算过了。\n所以每次循环开始之间 $dp[j]$ 记录的是 $dp[i - 1][j]$ 的信息。\n每次循环结束 $dp[j]$ 记录的是 $dp[i][j]$ 的信息。\n从前往后循环，每次更新时 $dp[j]&#x3D;dp[j-v[i]]+w[i]$ 等价于朴素做法的 $dp[i][j]&#x3D;dp[i][j-v[i]]+w[i]$，但是实际的目标是 $dp[i][j]&#x3D;dp[i-1][j-v[i]]+w[i]$。\n故从后往前循环，使每次的 $i$ 都是由 $i - 1$ 推出来的。因为 $dp[j-v[i]]$ 在本次循环尚未更新过，所以已经记录的是 $dp[i-1][j-v[i]]$ 的值。\n\n\n\n例题（Acwing）有$N$件物品和一个容量是$V$的背包。每件物品只能使用一次。第$i$件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。输入格式第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。接下来有$N$ 行，每行两个整数 $v_i$，$w_i$用空格隔开，分别表示第 $i$件物品的体积和价值。\n二维01背包实例代码：#include &lt;bits/stdc++.h&gt;\nusing namespace std;\nsigned main () &#123;\n    int n, m;\n    cin&gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt; v(n + 5), w(n + 5);\n    for(int i = 0; i &lt; n; i++) \n        cin&gt;&gt; v[i + 1] &gt;&gt; w[i + 1];\n\n    // 逆推\n    vector&lt;int&gt; dp(m + 5);\n    for(int i = 1; i &lt;= n; i++) \n        for(int j = m; j &gt;= v[i]; j--) \n            dp[j] = max(dp[j], dp[j - v[i]] + w[i]);\n\n    cout&lt;&lt; dp[m] &lt;&lt;endl;\n/*\n    // 滚动数组\n    vector&lt;int&gt; dp(m + 5), g(m + 5);\n    // dp 储存第i - 1行, g 储存第i行\n    for(int i = 1; i &lt;= n; i++) &#123;\n        for(int j = 1; j &lt;= m; j++) &#123;\n            if(j &lt; v[i])\n                g[j] = dp[j];\n            else \n                g[j] = max(dp[j], dp[j - v[i]] + w[i]);\n        &#125;\n        dp = g;\n    &#125; \n    cout&lt;&lt; dp[m] &lt;&lt;endl;\n\n    // 朴素暴力\n    vector&lt;vector&lt;int&gt; &gt; dp(n + 5, vector&lt;int&gt; (m + 5));\n    for(int i = 1; i &lt;= n; i++) \n        for(int j = 1; j &lt;= m; j++) \n            if(j &lt; v[i])\n                dp[i][j] = dp[i - 1][j];\n            else \n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);\n                \n    cout&lt;&lt; dp[n][m] &lt;&lt;endl;\n*/\n    return 0;\n&#125;\n","slug":"01背包","date":"2024-01-08T13:04:19.000Z","categories_index":"算法","tags_index":"算法,Cpp","author_index":"KAZEmae"}]
{"title":"洛谷[P1111] 修复公路","uid":"04f8e9ebd29b313fc8963f63caba7d79","slug":"洛谷-P1111-修复公路","date":"2024-01-08T13:10:39.000Z","updated":"2024-01-08T14:42:04.000Z","comments":true,"path":"api/articles/洛谷-P1111-修复公路.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/eqbjc9m9.png","content":"<p><a href=\"https://www.luogu.com.cn/problem/P1111\">原题链接</a></p>\n<h1 id=\"原题：\"><a href=\"#原题：\" class=\"headerlink\" title=\"原题：\"></a>原题：</h1><h4 id=\"题目背景\"><a href=\"#题目背景\" class=\"headerlink\" title=\"题目背景\"></a>题目背景</h4><p>A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。</p>\n<h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><p>给出 A 地区的村庄数 $N$，和公路数 $M$，公路是双向的。并告诉你每条公路的连着哪两个村庄，并告诉你什么时候能修完这条公路。问最早什么时候任意两个村庄能够通车，即最早什么时候任意两条村庄都存在至少一条修复完成的道路（可以由多条公路连成一条道路）。</p>\n<h4 id=\"输入格式\"><a href=\"#输入格式\" class=\"headerlink\" title=\"输入格式\"></a>输入格式</h4><p>第 $1$ 行两个正整数 $N,M$。<br>下面 $M$ 行，每行 $3$ 个正整数 $x,y,t$，告诉你这条公路连着 $x,y$ 两个村庄，在时间t时能修复完成这条公路。</p>\n<h4 id=\"输出格式\"><a href=\"#输出格式\" class=\"headerlink\" title=\"输出格式\"></a>输出格式</h4><p>如果全部公路修复完毕仍然存在两个村庄无法通车，则输出 $-1$，否则输出最早什么时候任意两个村庄能够通车。</p>\n<h4 id=\"数据范围\"><a href=\"#数据范围\" class=\"headerlink\" title=\"数据范围\"></a>数据范围</h4><p>$1\\leq x, y\\leq N \\le 10 ^ 3$，$1\\leq M, t \\le 10 ^ 5$。</p>\n<h4 id=\"算法：-并查集\"><a href=\"#算法：-并查集\" class=\"headerlink\" title=\"算法：[[并查集]]\"></a>算法：[[并查集]]</h4><h1 id=\"思路：\"><a href=\"#思路：\" class=\"headerlink\" title=\"思路：\"></a>思路：</h1><ul>\n<li>题目没有提及，但看样例可知，所有公路是同时开工的。</li>\n<li>我们按时间排序，先判断时间用的更少的。</li>\n<li>将两个相连的村庄放入同一个集合。</li>\n<li>若联通集合中元素数目等于村庄数，则所有村庄已联通，输出现在的时间即可。</li>\n<li>若修完所有的路，集合中元素数仍然小于村庄数，则说明无法所有村庄实现联通。</li>\n</ul>\n<h1 id=\"实现：\"><a href=\"#实现：\" class=\"headerlink\" title=\"实现：\"></a>实现：</h1><h2 id=\"排序：\"><a href=\"#排序：\" class=\"headerlink\" title=\"排序：\"></a>排序：</h2><p>因为对 $t$ 排序， 要 $x, y$ 随 $t$ 一起移动，可使用结构体，（或者使用<code>pair&lt;int, pair&lt;int, int&gt; &gt;</code>  $first存储 t，second存储x,y$ ）</p>\n<h3 id=\"元素数统计：\"><a href=\"#元素数统计：\" class=\"headerlink\" title=\"元素数统计：\"></a>元素数统计：</h3><p>定义 <code>size[]</code> 数组</p>\n<ul>\n<li>全部初始化为$1$。</li>\n<li>如果两个村庄合并，则将新集合的祖宗节点的<code>size[]</code>大小更改为原先两个集合的元素数之和。</li>\n</ul>\n<h1 id=\"实例代码\"><a href=\"#实例代码\" class=\"headerlink\" title=\"实例代码\"></a>实例代码</h1><pre><code class=\"highlight c++\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span>\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n<span class=\"keyword\">using</span> ll = <span class=\"type\">long</span> <span class=\"type\">long</span>;\n<span class=\"meta\">#<span class=\"keyword\">define</span> endl <span class=\"string\">&quot;\\n&quot;</span></span>\n<span class=\"comment\">//#define int long long</span>\n\n<span class=\"type\">const</span> <span class=\"type\">int</span> N = <span class=\"number\">100005</span>; <span class=\"comment\">// 1e6+5</span>\n\n<span class=\"keyword\">struct</span> <span class=\"title class_\">LGY</span> &#123;\n    <span class=\"type\">int</span> x, y, t;\n&#125;;\n<span class=\"comment\">// 使sort按t排序</span>\n<span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">cmp</span> <span class=\"params\">(LGY a, LGY b)</span> </span>&#123;\n    <span class=\"keyword\">return</span> a.t &lt; b.t;\n&#125;\n<span class=\"comment\">// p数组存储父节点， siz数组存储集合元素个数</span>\n<span class=\"type\">int</span> p[N], siz[N];\nvector&lt;LGY&gt; a;\n<span class=\"comment\">// 查找祖宗节点函数，并路径压缩</span>\n<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;\n    <span class=\"keyword\">return</span> x == p[x] ? p[x] : p[x] = <span class=\"built_in\">find</span>(p[x]);\n&#125;\n<span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"type\">void</span>)</span> </span>&#123;\n    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>), cin.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"number\">0</span>);\n    <span class=\"type\">int</span> n, m, dx, ans = <span class=\"number\">0</span>;\n    LGY z;\n    cin&gt;&gt; n &gt;&gt; m;\n    <span class=\"comment\">// 初始化p数组和siz数组</span>\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++)\n        p[i] = i, siz[i] = <span class=\"number\">1</span>;\n    <span class=\"comment\">// 输入</span>\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= m; i++) &#123;\n        cin&gt;&gt; z.x &gt;&gt; z.y &gt;&gt; z.t;\n        a.<span class=\"built_in\">push_back</span>(z);\n    &#125;\n    <span class=\"comment\">// 排序</span>\n    <span class=\"built_in\">sort</span>(a.<span class=\"built_in\">begin</span>(), a.<span class=\"built_in\">end</span>(), cmp);\n    <span class=\"comment\">// 遍历每条路</span>\n    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i:a) &#123;\n\t    <span class=\"comment\">//如果 x, y 未联通</span>\n        <span class=\"keyword\">if</span>(<span class=\"built_in\">find</span>(i.x) != <span class=\"built_in\">find</span>(i.y)) &#123;\n\t        <span class=\"comment\">// 将 x, y 集合的元素数相加</span>\n            siz[<span class=\"built_in\">find</span>(i.y)] += siz[<span class=\"built_in\">find</span>(i.x)];\n            <span class=\"comment\">// 将 x 集合的祖宗节点指向 y 集合的祖宗节点</span>\n            p[<span class=\"built_in\">find</span>(i.x)] = <span class=\"built_in\">find</span>(i.y);\n            <span class=\"comment\">// 记录元素个数</span>\n            dx = siz[<span class=\"built_in\">find</span>(i.y)];\n            <span class=\"comment\">// 更新答案</span>\n            ans = i.t;\n        &#125;\n        <span class=\"comment\">// 如果所有村庄联通则脱出循环</span>\n        <span class=\"keyword\">if</span>(dx == n) <span class=\"keyword\">break</span>;\n    &#125;\n    <span class=\"comment\">// 判断是否所有村庄联通</span>\n    <span class=\"keyword\">if</span>(dx == n) cout&lt;&lt; ans ;\n    <span class=\"keyword\">else</span> cout&lt;&lt; <span class=\"number\">-1</span>;\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n","feature":false,"text":"原题链接 原题：题目背景A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。 题目描述给出 A 地区的村庄数 $N$，和公路数 ...","permalink":"/post/洛谷-P1111-修复公路","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"题解","slug":"题解","count":1,"path":"api/tags/题解.json"},{"name":"洛谷","slug":"洛谷","count":1,"path":"api/tags/洛谷.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">原题：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E8%83%8C%E6%99%AF\"><span class=\"toc-text\">题目背景</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0\"><span class=\"toc-text\">题目描述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输入格式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">输出格式</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4\"><span class=\"toc-text\">数据范围</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%EF%BC%9A-%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">算法：[[并查集]]</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF%EF%BC%9A\"><span class=\"toc-text\">思路：</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0%EF%BC%9A\"><span class=\"toc-text\">实现：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%EF%BC%9A\"><span class=\"toc-text\">排序：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%83%E7%B4%A0%E6%95%B0%E7%BB%9F%E8%AE%A1%EF%BC%9A\"><span class=\"toc-text\">元素数统计：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">实例代码</span></a></li></ol>","author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"Hello World","uid":"b9663f58f18133b35bfe243f3e916a80","slug":"hello-world","date":"2024-01-08T14:42:00.000Z","updated":"2024-01-08T14:42:00.000Z","comments":true,"path":"api/articles/hello-world.json","keywords":null,"cover":null,"text":"Welcome to Hexo! This is your very first post. Check documentation for more info...","permalink":"/post/hello-world","photos":[],"count_time":{"symbolsCount":440,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"feature":false},"next_post":{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2024-01-08T13:06:04.000Z","updated":"2024-01-08T14:42:06.000Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/w6ueye84.png","text":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵...","permalink":"/post/并查集","photos":[],"count_time":{"symbolsCount":719,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"Cpp","slug":"Cpp","count":4,"path":"api/tags/Cpp.json"}],"author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"feature":false}}
{"title":"CF1227D2题解","uid":"5bd0f00513c2b7bc63e18b965d15a571","slug":"CF1227D2题解","date":"2024-01-16T12:13:14.000Z","updated":"2024-01-16T13:00:32.000Z","comments":true,"path":"api/articles/CF1227D2题解.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/eqbjc9m9.png","content":"<p><a href=\"https://codeforces.com/contest/1227/problem/D2\">原题链接</a></p>\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>当查询子序列的长度为 $k$  时，序列 $a$  中前 $k$ 大的数一定会被选中，且相同大小的数越靠前越先被选中。</p>\n<p>根据上面的规则对序列 $a$ 排序并离散化得到序列 $b$。我们考虑 $k$ 依次取 $1, 2, \\cdots, n$ 时的子序列，显然将序列 $b$ 依次加入即可得到 $k$ 依次取 $1, 2, \\cdots, n$ 时的子序列。</p>\n<p>为了快速求得子序列的第 $pos$ 个数，我们使用树状数组来维护子序列，在树状数组上二分来求第 $pos$ 个数。</p>\n<p>时间复杂度 $O(n\\times\\log(n))$</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><pre><code class=\"highlight c++\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span>\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n\n<span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;\n<span class=\"keyword\">struct</span> <span class=\"title class_\">BIT</span> &#123;\n    <span class=\"type\">int</span> n;\n    vector&lt;T&gt; c;\n    <span class=\"comment\">// 构造函数</span>\n    <span class=\"built_in\">BIT</span>(<span class=\"type\">int</span> len) : <span class=\"built_in\">n</span>(len), <span class=\"built_in\">c</span>(n + <span class=\"number\">1</span>) &#123;&#125;\n    <span class=\"comment\">// 初始化</span>\n    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(vector&lt;<span class=\"type\">int</span>&gt; &amp;a)</span> </span>&#123;\n        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>, j = <span class=\"number\">0</span>; i &lt;= n; ++ i) &#123;\n            c[i] += a[i], j = i + ((i) &amp; (-i));\n            <span class=\"keyword\">if</span>(j &lt;= n) c[j] += c[i];\n        &#125;\n    &#125;\n    <span class=\"comment\">// 修改 a[x] += s</span>\n    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"type\">int</span> x, T s)</span> </span>&#123;\n        <span class=\"built_in\">assert</span>(x != <span class=\"number\">0</span>);\n        <span class=\"keyword\">for</span>(; x &lt;= n; x += ((x) &amp; (- x)))\n            c[x] += s;\n    &#125;\n    <span class=\"comment\">// 查询 a[1]...a[x] 的和</span>\n    <span class=\"function\">T <span class=\"title\">sum</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;\n        <span class=\"built_in\">assert</span>(x &lt;= n);\n        T sum = <span class=\"number\">0</span>;\n        <span class=\"keyword\">for</span>(; x; x -= ((x) &amp; (- x))) \n            sum += c[x];\n        <span class=\"keyword\">return</span> sum;\n    &#125;\n    <span class=\"comment\">// 查询 a[l]...a[r] 的和</span>\n    <span class=\"function\">T <span class=\"title\">getsum</span><span class=\"params\">(<span class=\"type\">int</span> l, <span class=\"type\">int</span> r)</span> </span>&#123;\n        <span class=\"keyword\">if</span>(r &lt; l) <span class=\"built_in\">swap</span>(l, r);\n        <span class=\"keyword\">return</span> <span class=\"built_in\">sum</span>(r) - <span class=\"built_in\">sum</span>(l - <span class=\"number\">1</span>);\n    &#125;\n    <span class=\"comment\">// 查询最大的 pos, 满足 a[1]+...+a[pos] &lt;= k</span>\n    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(T k)</span> </span>&#123;\n        <span class=\"type\">int</span> l = <span class=\"number\">0</span>;\n        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"built_in\">log2</span>(n); i &gt;= <span class=\"number\">0</span>; -- i)\n            <span class=\"keyword\">if</span>(l + (<span class=\"number\">1</span> &lt;&lt; i) &lt;= n &amp;&amp; c[l + (<span class=\"number\">1</span> &lt;&lt; i)] &lt;= k)\n                l += (<span class=\"number\">1</span> &lt;&lt; i), k -= c[l];\n        <span class=\"keyword\">return</span> l;\n    &#125;\n&#125;;\n\n<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span></span>;\n<span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;\n    std::ios::<span class=\"built_in\">sync_with_stdio</span>(<span class=\"literal\">false</span>), cin.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>), cout.<span class=\"built_in\">tie</span>(<span class=\"literal\">nullptr</span>);\n    <span class=\"comment\">// cout&lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(10);</span>\n    <span class=\"comment\">// int _ = 1; cin&gt;&gt; _; while(_ --)</span>\n        <span class=\"built_in\">solve</span>();\n  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;\n<span class=\"comment\">// #define int long long</span>\n\n<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">solve</span><span class=\"params\">()</span> </span>&#123;\n    <span class=\"type\">int</span> n, m, k, p;\n    cin&gt;&gt; n;\n    <span class=\"function\">BIT&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">tr</span><span class=\"params\">(n)</span></span>;\n    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">a</span><span class=\"params\">(n)</span>, <span class=\"title\">b</span><span class=\"params\">(n)</span></span>;\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++ i) \n        cin&gt;&gt; a[i];\n\n    <span class=\"comment\">// 离线</span>\n    cin&gt;&gt; m;\n    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">ans</span><span class=\"params\">(m)</span></span>;\n    vector&lt;vector&lt;pair&lt;<span class=\"type\">int</span>, <span class=\"type\">int</span>&gt; &gt; &gt; <span class=\"built_in\">q</span>(n);\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; m; ++ i) &#123;\n        cin&gt;&gt; k &gt;&gt; p;\n        q[k - <span class=\"number\">1</span>].<span class=\"built_in\">push_back</span>(&#123;p, i&#125;);\n    &#125;\n\n    <span class=\"comment\">// 排序, 离散化</span>\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++ i) b[i] = i;\n    <span class=\"built_in\">sort</span>(b.<span class=\"built_in\">begin</span>(), b.<span class=\"built_in\">end</span>(), [&amp;](<span class=\"type\">int</span> i, <span class=\"type\">int</span> j) &#123;\n        <span class=\"built_in\">return</span> (a[i] &gt; a[j] || (a[i] == a[j] &amp;&amp; i &lt; j));\n    &#125;);\n\n    <span class=\"comment\">// 查询</span>\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++ i) &#123;\n        tr.<span class=\"built_in\">add</span>(b[i] + <span class=\"number\">1</span>, <span class=\"number\">1</span>);\n        <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> j : q[i]) \n            ans[j.second] = a[tr.<span class=\"built_in\">find</span>(j.first - <span class=\"number\">1</span>)];\n    &#125;\n\n    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span> i : ans) cout &lt;&lt; i &lt;&lt;endl;\n&#125;</code></pre>\n\n","feature":true,"text":"原题链接 思路当查询子序列的长度为 $k$ 时，序列 $a$ 中前 $k$ 大的数一定会被选中，且相同大小的数越靠前越先被选中。 根据上面的规则对序列 $a$ ...","permalink":"/post/CF1227D2题解","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"数组数组","slug":"数组数组","count":1,"path":"api/tags/数组数组.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">思路</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">代码实现</span></a></li></ol>","author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"对拍器","uid":"afbdc662f7a3047fa9981dc983cb9e4b","slug":"对拍器","date":"2024-01-08T13:06:00.000Z","updated":"2024-01-08T14:42:04.000Z","comments":true,"path":"api/articles/对拍器.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/8qdyho6c.png","text":"对拍是什么对拍，是一个比较实用的工具。它能够非常方便地对于两个程序的输出文件进行比较，可以帮助我们实现一些自动化的比较输出结果的问题。 众所周知，几乎每一道编程...","permalink":"/post/对拍器","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"Cpp","slug":"Cpp","count":4,"path":"api/tags/Cpp.json"},{"name":"工具","slug":"工具","count":2,"path":"api/tags/工具.json"}],"author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"feature":true}}
{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2024-01-08T13:06:04.000Z","updated":"2024-01-08T14:42:06.000Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/w6ueye84.png","content":"<h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵树等。</p>\n<h3 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h3><p>并查集的主要作用是求连通分支数（如果一个图中所有点都存在可达关系（直接或间接相连），则此图的连通分支数为1；如果此图有两大子图各自全部可达，则此图的连通分支数为2……）</p>\n<h2 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h2><h3 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h3><p>将每个节点的祖宗节点指向自己，故祖宗节点的特质是<strong>它的父节点是自己</strong>，<code>p[x] == x</code></p>\n<pre><code class=\"highlight c++\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) \n\tp[i] = i;</code></pre>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><p>首先我们需要定义一个数组：<code>int p[];</code> 用于记录每个节点的父节点是哪个节点（数组长度依题意而定）。这个数组记录了每个人的父节点是谁。<br>路径压缩：每次查询将沿路的节点全部指向父节点，这样操作之后每次查询的复杂度为$O(1)$</p>\n<pre><code class=\"highlight c++\"><span class=\"comment\">//写法1：</span>\n<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;\n    <span class=\"keyword\">return</span> x == p[x] ? p[x] : p[x] = <span class=\"built_in\">find</span>(p[x]); \n    <span class=\"comment\">// 如果当前节点不是祖宗节点则查找当前节点的父节点，一直递归到祖宗节点</span>\n    <span class=\"comment\">//并把沿路所有节点指向祖宗节点</span>\n&#125;\n<span class=\"comment\">//写法2：</span>\n<span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">find</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>&#123;\n\t<span class=\"keyword\">if</span>(x != p[x]) p[x] = <span class=\"built_in\">find</span>(p[x]);\n\t<span class=\"keyword\">return</span> p[x];\n&#125;</code></pre>\n<h3 id=\"并\"><a href=\"#并\" class=\"headerlink\" title=\"并\"></a>并</h3><p>将 $x,y$ 各自所属的集合合并，查询 $x,y$ 各自的祖宗节点，然后将 $y$ 的祖宗节点指向 $x$ 的祖宗节点。</p>\n<pre><code class=\"highlight c++\">p[<span class=\"built_in\">find</span>(y)] = <span class=\"built_in\">find</span>(x);\n<span class=\"comment\">// 将 y 的祖宗节点指向 x 的祖宗节点</span></code></pre>\n","feature":false,"text":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵...","permalink":"/post/并查集","photos":[],"count_time":{"symbolsCount":719,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":7,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":6,"path":"api/tags/算法.json"},{"name":"Cpp","slug":"Cpp","count":4,"path":"api/tags/Cpp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">作用：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9F%A5\"><span class=\"toc-text\">查</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6\"><span class=\"toc-text\">并</span></a></li></ol>","author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"洛谷[P1111] 修复公路","uid":"04f8e9ebd29b313fc8963f63caba7d79","slug":"洛谷-P1111-修复公路","date":"2024-01-08T13:10:39.000Z","updated":"2024-01-08T14:42:04.000Z","comments":true,"path":"api/articles/洛谷-P1111-修复公路.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/eqbjc9m9.png","text":"原题链接 原题：题目背景A 地区在地震过后，连接所有村庄的公路都造成了损坏而无法通车。政府派人修复这些公路。 题目描述给出 A 地区的村庄数 $N$，和公路数 ...","permalink":"/post/洛谷-P1111-修复公路","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":7,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":6,"path":"api/tags/算法.json"},{"name":"数据结构","slug":"数据结构","count":2,"path":"api/tags/数据结构.json"},{"name":"题解","slug":"题解","count":2,"path":"api/tags/题解.json"},{"name":"洛谷","slug":"洛谷","count":1,"path":"api/tags/洛谷.json"}],"author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"feature":false},"next_post":{"title":"01背包","uid":"d26940bc311bdaabb8d1c2107d93235d","slug":"01背包","date":"2024-01-08T13:04:19.000Z","updated":"2024-01-08T14:42:02.000Z","comments":true,"path":"api/articles/01背包.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/m31u4e22.png","text":"01背包每件物品只能装一次 朴素二维动态规划 $dp[i][j]：$$i$表示当前对第$i$个物品判断，$j$表示当前背包最大容量为$j$，$dp[i][j]$...","permalink":"/post/01背包","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":7,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":6,"path":"api/tags/算法.json"},{"name":"Cpp","slug":"Cpp","count":4,"path":"api/tags/Cpp.json"}],"author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"feature":false}}
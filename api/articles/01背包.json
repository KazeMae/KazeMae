{"title":"01背包","uid":"d26940bc311bdaabb8d1c2107d93235d","slug":"01背包","date":"2024-01-08T13:04:19.000Z","updated":"2024-01-08T14:42:02.000Z","comments":true,"path":"api/articles/01背包.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/m31u4e22.png","content":"<p><strong>01背包每件物品只能装一次</strong></p>\n<h3 id=\"朴素二维动态规划\"><a href=\"#朴素二维动态规划\" class=\"headerlink\" title=\"朴素二维动态规划\"></a>朴素二维动态规划</h3><ul>\n<li>$dp[i][j]：$$i$表示当前对第$i$个物品判断，$j$表示当前背包最大容量为$j$，$dp[i][j]$ 表示第$i$个物品最大空间为$j$时背包能装最大价值。</li>\n<li>$v[i]$表示第$i$个物品的体积。</li>\n<li>$w[i]$表示第$i$个物品的价值。</li>\n</ul>\n<p>分析：</p>\n<ol>\n<li>当 $j-v[i] \\ge 0$ 时：$$dp[i][j]&#x3D;max(dp[i-1][j],dp[i-1][j-v[i]] + w[i])$$</li>\n<li>当 $j-v[i] &lt; 0$ 时：$$dp[i][j] &#x3D; dp[i - 1][j]$$</li>\n</ol>\n<h3 id=\"滚动数组\"><a href=\"#滚动数组\" class=\"headerlink\" title=\"滚动数组\"></a>滚动数组</h3><pre><code class=\"highlight C++\"><span class=\"comment\">// 滚动数组</span>\n    \n    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(m + <span class=\"number\">5</span>)</span>, <span class=\"title\">g</span><span class=\"params\">(m + <span class=\"number\">5</span>)</span></span>;\n    \n    <span class=\"comment\">// dp 储存第i - 1行, g 储存第i行</span>\n\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;\n        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">1</span>; j &lt;= m; j++) &#123;\n            <span class=\"keyword\">if</span>(j &lt; v[i])\n                g[j] = dp[j];\n            <span class=\"keyword\">else</span> \n                g[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - v[i]] + w[i]);\n        &#125;\n        dp = g;\n    &#125; \n    cout&lt;&lt; dp[m] &lt;&lt;endl;</code></pre>\n\n\n\n<h3 id=\"状态压缩：一维动态规划\"><a href=\"#状态压缩：一维动态规划\" class=\"headerlink\" title=\"状态压缩：一维动态规划\"></a>状态压缩：一维动态规划</h3><ol>\n<li>首先其实可以发现整个转移方程中对于 $i$ 这一维，只用到了 $i -1$， 所以我们其实并不需要记录所有的 $dp[i][..]$，相反只需要用单个变量记录即可（滚动数组）。</li>\n<li>去除$i$这一维后，我们碰到了一些问题:<ul>\n<li>对于$j$ 这一维因为 $j - v[i] &lt; j$，所以实际上 $dp[j - v[i]]$ 这个状态已经计算过了。</li>\n<li>所以每次循环开始之间 $dp[j]$ 记录的是 $dp[i - 1][j]$ 的信息。</li>\n<li>每次循环结束 $dp[j]$ 记录的是 $dp[i][j]$ 的信息。</li>\n<li>从前往后循环，每次更新时 $dp[j]&#x3D;dp[j-v[i]]+w[i]$ 等价于朴素做法的 $dp[i][j]&#x3D;dp[i][j-v[i]]+w[i]$，但是实际的目标是 $dp[i][j]&#x3D;dp[i-1][j-v[i]]+w[i]$。</li>\n<li>故从后往前循环，使每次的 $i$ 都是由 $i - 1$ 推出来的。因为 $dp[j-v[i]]$ 在本次循环尚未更新过，所以已经记录的是 $dp[i-1][j-v[i]]$ 的值。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"例题（Acwing）\"><a href=\"#例题（Acwing）\" class=\"headerlink\" title=\"例题（Acwing）\"></a>例题（Acwing）</h3><p>有$N$件物品和一个容量是$V$的背包。每件物品只能使用一次。<br>第$i$件物品的体积是 $v_i$，价值是 $w_i$。<br>求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。<br>输出最大价值。<br><strong>输入格式</strong><br>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。<br>接下来有$N$ 行，每行两个整数 $v_i$，$w_i$用空格隔开，分别表示第 $i$件物品的体积和价值。</p>\n<h5 id=\"二维01背包实例代码：\"><a href=\"#二维01背包实例代码：\" class=\"headerlink\" title=\"二维01背包实例代码：\"></a>二维01背包实例代码：</h5><pre><code class=\"highlight c++\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;bits/stdc++.h&gt;</span></span>\n<span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;\n<span class=\"function\"><span class=\"type\">signed</span> <span class=\"title\">main</span> <span class=\"params\">()</span> </span>&#123;\n    <span class=\"type\">int</span> n, m;\n    cin&gt;&gt; n &gt;&gt; m;\n    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v</span><span class=\"params\">(n + <span class=\"number\">5</span>)</span>, <span class=\"title\">w</span><span class=\"params\">(n + <span class=\"number\">5</span>)</span></span>;\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) \n        cin&gt;&gt; v[i + <span class=\"number\">1</span>] &gt;&gt; w[i + <span class=\"number\">1</span>];\n\n    <span class=\"comment\">// 逆推</span>\n    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">dp</span><span class=\"params\">(m + <span class=\"number\">5</span>)</span></span>;\n    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) \n        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = m; j &gt;= v[i]; j--) \n            dp[j] = <span class=\"built_in\">max</span>(dp[j], dp[j - v[i]] + w[i]);\n\n    cout&lt;&lt; dp[m] &lt;&lt;endl;\n<span class=\"comment\">/*</span>\n<span class=\"comment\">    // 滚动数组</span>\n<span class=\"comment\">    vector&lt;int&gt; dp(m + 5), g(m + 5);</span>\n<span class=\"comment\">    // dp 储存第i - 1行, g 储存第i行</span>\n<span class=\"comment\">    for(int i = 1; i &lt;= n; i++) &#123;</span>\n<span class=\"comment\">        for(int j = 1; j &lt;= m; j++) &#123;</span>\n<span class=\"comment\">            if(j &lt; v[i])</span>\n<span class=\"comment\">                g[j] = dp[j];</span>\n<span class=\"comment\">            else </span>\n<span class=\"comment\">                g[j] = max(dp[j], dp[j - v[i]] + w[i]);</span>\n<span class=\"comment\">        &#125;</span>\n<span class=\"comment\">        dp = g;</span>\n<span class=\"comment\">    &#125; </span>\n<span class=\"comment\">    cout&lt;&lt; dp[m] &lt;&lt;endl;</span>\n<span class=\"comment\"></span>\n<span class=\"comment\">    // 朴素暴力</span>\n<span class=\"comment\">    vector&lt;vector&lt;int&gt; &gt; dp(n + 5, vector&lt;int&gt; (m + 5));</span>\n<span class=\"comment\">    for(int i = 1; i &lt;= n; i++) </span>\n<span class=\"comment\">        for(int j = 1; j &lt;= m; j++) </span>\n<span class=\"comment\">            if(j &lt; v[i])</span>\n<span class=\"comment\">                dp[i][j] = dp[i - 1][j];</span>\n<span class=\"comment\">            else </span>\n<span class=\"comment\">                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + w[i]);</span>\n<span class=\"comment\">                </span>\n<span class=\"comment\">    cout&lt;&lt; dp[n][m] &lt;&lt;endl;</span>\n<span class=\"comment\">*/</span>\n    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;\n&#125;</code></pre>\n","feature":false,"text":"01背包每件物品只能装一次 朴素二维动态规划 $dp[i][j]：$$i$表示当前对第$i$个物品判断，$j$表示当前背包最大容量为$j$，$dp[i][j]$...","permalink":"/post/01背包","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"Cpp","slug":"Cpp","count":4,"path":"api/tags/Cpp.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%B4%E7%B4%A0%E4%BA%8C%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">朴素二维动态规划</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%BB%9A%E5%8A%A8%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">滚动数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%8A%B6%E6%80%81%E5%8E%8B%E7%BC%A9%EF%BC%9A%E4%B8%80%E7%BB%B4%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92\"><span class=\"toc-text\">状态压缩：一维动态规划</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BE%8B%E9%A2%98%EF%BC%88Acwing%EF%BC%89\"><span class=\"toc-text\">例题（Acwing）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E7%BB%B401%E8%83%8C%E5%8C%85%E5%AE%9E%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A\"><span class=\"toc-text\">二维01背包实例代码：</span></a></li></ol></li></ol></li></ol>","author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"mapped":true,"hidden":false,"prev_post":{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2024-01-08T13:06:04.000Z","updated":"2024-01-08T14:42:06.000Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":"https://cdn.luogu.com.cn/upload/image_hosting/w6ueye84.png","text":"定义并查集是一种树型的数据结构，用于处理一些不相交集合的合并及查询问题（即所谓的并、查）。比如说，我们可以用并查集来判断一个森林中有几棵树、某个节点是否属于某棵...","permalink":"/post/并查集","photos":[],"count_time":{"symbolsCount":719,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":6,"path":"api/categories/算法.json"}],"tags":[{"name":"算法","slug":"算法","count":5,"path":"api/tags/算法.json"},{"name":"Cpp","slug":"Cpp","count":4,"path":"api/tags/Cpp.json"}],"author":{"name":"KAZEmae","slug":"blog-author","avatar":"https://cdn.luogu.com.cn/upload/image_hosting/ta8dbhtt.png","link":"/","description":"","socials":{"github":"https://github.com/KazeMae","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/su-mu-78-85-44","csdn":"https://blog.csdn.net/weixin_73404823","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/248618134"},"codeforce":{"icon":"/svg/codeforces.svg","link":"https://codeforces.com/profile/Remaining_Lotus"}}}},"feature":false},"next_post":{}}